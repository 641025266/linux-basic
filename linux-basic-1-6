linux基础面题---------------------------------------------------------------------------------------------------------------------------------------------
案例：
有用户manager、renshi、xingzheng，文件夹renshi，xingzheng，要求manager用户可以查看并更改renshi，xingzheng文件夹下的文件，
renshi用户只能查看修改renshi文件夹，xingzheng用户只能查看修改xingzheng文件夹。其他人不能访问该两个文件夹。
答案：
usermod -G -a renshi，xingzheng manager     给manager增加附加组renshi和xingzheng
chown renshi.renshi renshi 
chmod 770 renshi
chown xingzheng.xingzheng xingzheng 
chmod 770 xingzheng 

案例：常用服务端口
9000：php-fpm
8080：tomat的http
8009：tomcat的ajp
8005：tomcat的一个集群端口，接受shutdown命令
9090：haproxy做负载均衡时，正常监听在80端口，但是它有一个图形界面的管理接口
6081：varnish默认端口
6082: varnish监听在127.0.0.1的管理端口
27017：mongodb
27017:mongodb监听端口
27019:在mongodb的sharding集群中，config server监听的地址
28017：mongodb的http监听端口
11211：memcached
6379： redis
26379: redis中的sentinel监听节点
7500和7501：mogilefs
25：smtp    注意把同SNMP做区别，  SNMP表示简单网络管理协议
110：pop3
53：DNS
7001: mogilefs的tracker节点监听端口
7500：mogilefs的mogstored节点监听的http端口
7501：mogilefs的mogstored节点监听的管理端口


案例：
linux 查看从本地到218.56.57.58的路由链路情况的命令是：route -eeFCn|grep 218.56.57.58

案例：
检查硬盘sda读写速度的命令是：
[root@node1 ~]# dd if=/dev/zero of=/tmp/test.txt bs=1M count=1000 
1000+0 records in
1000+0 records out
1048576000 bytes (1.0 GB) copied, 46.8358 s, 22.4 MB/s



案例：
查看服务器cpu型号的命令是：
   [root@localhost tmp]# awk -F ':'  '/model name/{print $2}' /proc/cpuinfo
   Intel(R) Core(TM) i3-3110M CPU @ 2.40GHz


案例：
linux系统如果要对一个5T的存储阵列sda进行分区，应该使用什么命令分区，使用什么分区表？需要分配两个100G空间的，剩余空间给第三个分区，请提供命令：
超过2TB的分区就要用parted来分区，此时fdisk已经不能使用了
用parted 来分区，yum install -y parted安装。使用gpt分区表来分区。
分区步骤：
parted /dev/sda   指定要分区的磁盘，进入后再继续执行下面的命令
mklabel gpt                指定分区表格式
mkpart primary 0 100G      第一个100G分区
mkpart primary 100G 200G   第二个100G分区
mkpart primary 200G -1     最后一个分区
exit 退出并保存

案例：
一个分区的标签为XXX 以标签形式挂在/tmp/mnt下，命令格式为？单机需要挂载IP-SAN设备时，需要在/etc/fstab文件设置挂载点时需要注意什么参数？
mount -L "XXX" /tmp/mnt
要增加_netdev参数，这意思是挂载这个设置之前，先要开启网络服务，因为IP-SAN依赖网络，IP-SAN就是iscsi


案例：
假设存在anymacro-4.8-txt-5.iso 已知/usr/bin/anysetup是该iso的一个rpm生成的文件，请给找出到该文件所属rpm的方法，如何挂载ISO镜像并取出此rpm包放到/tmp目录下？
答案：
mount -t iso9660 -o loop anymacro-4.8-txt-5.iso /mnt/   估计不用加-o loop也可以 
find  /mnt -type f -name $(rpm -qf /usr/bin/anysetup) -exec cp -rf {} /tmp/  \;


案例：
写一个脚本查找最后创建时间是3天前，后缀是*.log的文件
find  /var/log  -name  "*.log"  -mtime  +3	带有统配符时必须加引号，否则不能正确匹配			
案例：
用find 命令清理系统/mail分区下所有后缀为 “.lock”文件，命令为：
find /mail -type f -name “*.lock”-exec rm -rf {} \;
find /mail -type f -name “*.lock”|xargs -i rm -rf {} 
案例：
将/home/tong/test 目录下大于100K的文件转移到/tmp目录：
find /home/tong/test -type f -szie +100k |xargs -i mv {} /tmp/    此处必须要有-i和{}
find /home/tong/test -type f -szie +100k -exec  mv {} /tmp/   \;
注意：使用find命令时，不切换到你要找的目录里面去，比如此处不能切换到/home/tong/test里面去，否则会报错误

案例：
找出/taomee目录下的所有常规文件并设置权限644
答案：find taomee/ -type f |xargs -i chmod 644 {}


案例：
exec和souce区别
答案：
source就是让script在当前shell内执行、而不是产生一个sub-shell来执行。
exec也是让script在同一个行程上执行，但是原有行程则被结束了。此处的exec指的就是find命令中的exec
简而言之：原有行程会否终止，就是exec与source/fork的最大差异了。


补充说明：
   脚步执行两种方式的区别
   1）bash test.sh或者sh test.sh或者./test.sh都是在子shell中完成
   2）source test.sh或者. test.sh是在当前shell完成。这也是为什么可以不注销系统而要让某些写入~/.bashrc的设置生效时，需要使用source ~/.bashrc而不能使用bash ~/.bashrc
   详细理解参考鸟哥基础篇379页




案例;
Cetnos6.0系统默认语言是英文，我如何将操作系统的默认语言修改为简体中文（utf-8格式）？
答案：
[root@localhost ~]# vim /etc/sysconfig/i18n
LANG=zh_CN.UTF-8

案例:
查看aminglinux.com的域名的mx，ns，txt记录的方法？说明这些记录的差别？如何确认某个ip地址是否已经做反向解析。
答案：
dig -t MX aminglinux.com  查看SOA,NS,MX时后面跟的都是域名，不是完整主机名，切记
dig -t NS aminglinux.com
dig -x IP 做反向解析

MX记录主要用来做邮件服务器的域名记录，标明这是一台邮件服务器
NS记录主要是用来做DNS服务器的记录，标明这是一台DNS服务器
TXT 记录主要用来做域名的说明。比如：域名所有者的信息。
nslookup -qa=ptr ip地址，如果有返回正确的域名，就表示反解析正常。

案例：
CentOS6.0安装系统时主机名和DNS服务器设置设错了，请给出具体要修改的文件：
答案：
/etc/hosts和/etc/sysconfig/network        都要修改
/etc/sysconfig/network-scripts/ifcfg-eth0 设置DNS



案例：
简要描述Linux无盘值守安装过程，实际就是pxe
答案：
PXE网卡启动-->DHCP服务器-->获得IP-->从TFTP上下载pxelinux.0、vmlinuz、initrd-->启动系统-->通过PXE去HTTP或NFS或FTP下载ks.cfg文件
-->跟据ks.cfg去HTTP或NFS或FTP下载RPM包及安装系统-->完成安装。
所以我们需要安装的服务有dhcp、tftp、http/ftp、kickstart，同时也需要编辑合适的ks.cfg。这个文件就是规定安装哪些rpm包的。


案例：
目前有一套2台Linux组成的MySql双机热备系统 ，使用heartbeat或者你所熟悉的HA软件，进行双机切换测试，数据库版本为MySql5.5，写下双机切换的测试验证过程。

说明：这个题目考察的是大家对HA架构的熟练程度，遇上这样的题目多半是需要你上机操作的，如果是虚拟机实验，
安装步骤是：
   1. 两台机器分别安装mysql  
   2. 第一台部署NFS，第二台挂载NFS  
   3. 两台安装heartbeat或者corosync+pacemaker+crmsh
当然，线上环境不建议做NFS，因为mysql对磁盘IO有很高的要求，生产环境可以考虑drbd


案例：
基于Linux的系统监控或性能监控，写下你熟悉的一种监控软件（Nagios，Cacti，Nmon或者其他工具或命令）能控制哪些性能指标，报警有哪些级别，有哪些报警方式。

监控软件是Zabbix
性能监控指标有cpu、内存、磁盘、进程、用户、文件、服务等基础项目；也可以自定义监控项目，通过shell或者python等脚本实现。
报警级别有Information，Warning，Average，High，Disaster
报警方式有邮件、短信、微信等




案例：
如何查看httpd占用线程及线程所在目录
ps  aux |grep httpd    查看所有线程，记住第二列的数字即pidnumber
ls -l /proc/pidnumber 



案例：
现代操作系统的基本的特征是（ C ）资源共享和操作的异步性
A.多道程序设计	        B.中断处理
C.程序的并发执行	D.实现分时与实时处理

解释：批处理系统有着高的资源利用率和系统吞吐量；分时系统能获得及时响应；实时系统具有实时特征。除此之外，它们还共同具有并发、共享、虚拟和异步四个基本特征。
多道程序设计：
    是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。
多道程序设计特征：多道、宏观上并行、微观上串行。
并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。
吞吐量：吞吐量是指对网络、设备、端口、虚电路或其他设施，单位时间内成功地传送数据的数量（以比特、字节、分组等测量）。


案例：
Linux服务器上的tomcat进程经常出现假死的情况，当你遇到这种问题时怎么处理该问题及采取怎样的预防措施？
答案：
先排查假死时机器的负载，是否因为内存不足，cpu使用过高，或者磁盘问题等导致。
临时解决办法是写个脚本监控tomcat进程状况和模拟用户访问web站点，当出现不正常时，重启tomcat。
另外还需要写一个监控系统各个硬件状态的脚本，比如cpu、内存、磁盘、交换分区等，综合分析tomcat假死的原因，找问题是一个漫长和痛苦的事情，需要多一些耐心，
还需要我们敢去猜测，当然根据tomcat、系统相关的日志来获取一些信息也是非常有用的。


案例：
忘记系统密码
a、重启系统，在GRUB界面，选取忘记密码的系统，按e键进入编辑模式
b、选项Kernel.....按e键进行编辑
c、在编辑界面rhgbquiet后加空格，然后输入"single"或"1"回车
d、按b启动进入单用户模式
f、进入系统后passwd回车输入新密码(如果有selinux，先暂时关闭setenforce0)


案例：
某一天突然发现Linux系统文件只读，该怎么办呢？完整操作步骤。
答：
首先把系统关机，然后以光盘启动进入救援模式(linuxrescue),
执行"fsck.ext3 -y  /dev/sda2"（假如只读的分区类型为ext3，分区为/dev/sda2）
但在修复之前最好是把重要数据做一个备份以防万一。如果修复失败，那说明是磁盘损坏，这就需要更换磁盘了。
mount -o remount,rw /


案例：
用虚拟机安装了一台Linux系统，突然想克隆一台服务器，克隆后发现无法上网，如何解决？
答：
a、编辑网卡配置文件/etc/sysconfig/network-scripts/ifcfg-eth0,将HWADDR和MAC地址这两行删除。
b、修改文件/etc/udev/rules.d/70-persistent-net.rules,删除之前eth0所在的行，将下一行eth1修改为eth0
c、modprobe -r e1000然后再modprobe  e1000

案例：
dmesg命令中看到ip_conntrack: table full， dropping packet如何解决？
答案：
ip_conntrack表的最大值由参数ip_conntrack_max控制，查看当前设置的最大值可通过命令： cat /proc/sys/net/ipv4/ip_conntrack_max
redhat默认大小是65536，这个值的大小是由机器的内存决定的，65536是1G内存的大小，如果你的内存不止1G，那么设置的数值大小就是65536的倍数。2G是131072，4G是262144。
数值可以比当前内存可设置的最大值小，但是不能超过最大值，要不然设置之后是不生效的。
要查看当前系统ip_conntrack的大小可以通过命令：cat /proc/sys/net/ipv4/netfilter/ip_conntrack_count


案例：
简要描述Linux的启动过程？
答案：
A. 启动第一步 加载BIOS
   当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。
   这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，计算机心里就有谱了，知道应该去读取哪个硬件设备了。
B. 启动第二步读取MBR
   硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，别看地方不大，可里面却存放了预启动信息、分区表信息。
   系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。
C. 启动第三步 Boot Loader
   Boot Loader就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，
   以便为最终调用操作系统内核做好一切准备。Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。
D. 启动第四步 加载内核
   根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。
   当解压缩内核完成后，屏幕输出“OK, booting the kernel”。
   系统将解压后的内核放置在内存之中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。
   至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。
E. 启动第五步 用户层init依据inittab文件来设定运行等级
   内核被加载后，第一个运行的程序便是/sbin/init，该文件会读取/etc/inittab文件，并依据此文件来进行初始化工作。
  其实/etc/inittab文件最主要的作用就是设定Linux的运行等级，其设定形式是“：id:5:initdefault:”，这就表明Linux需要运行在等级5上。
Linux的运行等级设定如下：
0：关机
1：单用户模式
2：无网络支持的多用户模式
3：有网络支持的多用户模式
4：保留，未使用
5：有网络支持有X-Window支持的多用户模式
6：重新引导系统，即重启

F. 启动第六步 init进程执行rc.sysinit
   在设定了运行等级后，Linux系统执行的第一个用户层文件就是/etc/rc.d/rc.sysinit脚本程序，

G. 启动第七步 启动内核模块
   具体是依据/etc/modules.conf文件或/etc/modules.d目录下的文件来装载内核模块。
H. 启动第八步 执行不同运行级别的脚本程序
   根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务。
I. 启动第九步 执行/etc/rc.d/rc.local
你如果打开了此文件，里面有一句话，读过之后，你就会对此命令的作用一目了然：
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don’t
# want to do the full Sys V style init stuff.
rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。你可以把你想设置和启动的东西放到这里。

J. 启动第十步 执行/bin/login程序，进入登录状态
   系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。

总结：
内核空间级别： POST --> BootSequence(BIOS) --> BootLoader（MBR）--> Kernel（ramdisk）--> rootfs（readonly）--> /sbin/init ()

用户空间级别： /sbin/init-->设置默认运行级别 --> 运行系统初始化脚本，完成系统初始化（/etc/rc.d/rc.sysinit)
               --> 关闭对应级别下需要停止的服务，启动对应级别下需要开启的服务(/etc/rc.d/rcN.d-->/etc/rc.d/rc)--> 设置登录终端 [--> 启动图形终端]

补充说明：/sbin/init程序的配置文件有/etc/inittab和/etc/init/*.conf	


案例：
简单介绍一下您所知道的加速web服务器请求的方法。
答案：
A. 针对静态的访问，做过期时间，把静态文件缓存在客户端上
B. 在前端搭建squid反向代理，把静态的文件缓存在squid上
C. 接入CDN


案例：
办公室同事反馈网站打不开，请简述一下排查故障的思路或解决方法
答案：
A. 先ping一下域名，看看网络是否通
B. Telnet 一下服务器的80端口，看是否通；用ss -tunl也可以
C. 查看服务器流量是否正常，借助sar或者nload
D. 用w查看服务器是否有负载，
E. 用tcpdump抓包查看数据包是否正常，看是否有攻击
F. 查看配置是否正确


案例：
使用curl或wget命令获取http服务的header信息。
[root@localhost ~]# curl --head  http://192.168.139.130  或者使用-I也可以
HTTP/1.1 200 OK
Date: Sun, 01 Oct 2017 14:37:47 GMT
Server: Apache/2.2.15 (CentOS)
Last-Modified: Sun, 01 Oct 2017 14:36:33 GMT
ETag: "1c31-12-55a7d2f39ac76"
Accept-Ranges: bytes
Content-Length: 18
Connection: close
Content-Type: text/html; charset=UTF-8

案例：
real、user、sys三者具体代表的意思和区别
[root@localhost ~]# time sleep 2
real	0m2.030s
user	0m0.025s
sys	0m0.000s
程序的实际运行时间(real time)
程序运行在用户态的时间(user time)和内核态的时间(sys time)。
real并不等于user+sys的总和。
real代表的是程序从开始到结束的全部时间，即使程序不占CPU也统计时间。而user+sys是程序占用CPU的总时间，因此real总是大于或者等于user+sys的



案例：
请列举WEB常见安全问题（不少于三项），阐述其原理、危害。
1）跨站脚本漏洞
  Web应用程序直接将来自使用者的执行请求送回浏览器执行，使得攻击者可获取使用者的Cookie或Session信息而直接以使用者身份登陆
2）注入类问题
   Web应用程序执行在将用户输入变为命令或查询语句的一部分时没有做过滤，SQL 注入, 命令注入等攻击包括在内
3）DOS攻击


案例：
请列举常见DOS攻击类型，并分别介绍其原理和防御方法。

常见的DoS攻击类型
Land攻击：向某个设备发送数据包，并将数据包的源IP和目的IP都设置成攻击目标的地址。
DDos分布式拒绝服务攻击：攻击者攻破了多个系统。并利用这些系统去集中攻击其他目标。成千上万的主机发送大量的请求，受害设备因为无法处理而拒绝服务。
Ping of Death攻击：通过构造出重缓冲区大小异常的ICMP包进行攻击。
Smurf攻击：攻击者冒充受害主机的ip地址，向一个大的网络发送echo request 的定向广播包，此网络的许多主机都做出回应，受害主机会收到大龄的echo reply消息。
SYN Flooding 攻击：利用TCP连接的3次握手过程进行攻击。攻击者主机使用无效的IP地址。与受害主机进行TCP3次握手。在完成第2步后，受害主机就会处于开放会话的请求之中，
但会话并未真正完成。受害主机必须等待连接超时，之后才能清楚为完成的会话。在此期间，受害主机将会连续接收到这样的请求，最终因耗尽用来管理会话资源的资源而停止相应。

DOS攻击流程
第一次握手:建立连接时，客户端发送SYN包((SYN=i)到服务器，并进入SYN SEND状态，等待服务器确认;
第二次握手:服务器收到SYN包，必须确认客户的SYN (ACK=i+1 )，同时自己也发送一个SYN包((SYN=j)}即SYN+ACK包，此时服务器进入SYN_RECV状态
第三次握手:客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=j+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。


在上述过程中，还有一些重要的概念:
半连接队列:
     在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包(SYN=i )开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，
     正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_ RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。
Backlog参数:
     表示半连接队列的最大容纳数目，也可以称为后援消息队列
SYN-ACK重传次数:
     服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，
     如果重传次数超过系统规定的最大重传次数，系统将该连接信息、从半连接队列中删除。注意，每次重传等待的时间不一定相同。
半连接存活时间:
     是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。
     有时也称半连接存活时间为Timeout时间、SYN_RECV存活时间。

上面三个参数对系统的TCP连接状况有很大影响

案例：
从运维角度讲一下怎么预防cc攻击和ddos攻击
答案：先来说一下什么是cc攻击和ddos攻击。
1） CC=ChallengeCollapsar(挑战黑洞）主要是用来攻击页面的。大家都有这样的经历，就是在访问论坛时，如果这个论坛比较大，访问的人比较多，打开页面的速度会比较慢，
    访问的人越多，论坛的页面越多，数据库就越大，被访问的频率也越高，占用的系统资源也就相当可观。
    一个静态页面不需要服务器多少资源，甚至可以说直接从内存中读出来发给你就可以了，但是论坛就不一样了，我看一个帖子，系统需要到数据库中判断我是否有读帖子的权限，
    如果有，就读出帖子里面的内容，显示出来——这里至少访问了2次数据库，如果数据库的数据容量有200MB大小，系统很可能就要在这200MB大小的数据空间搜索一遍，
    这需要多少的CPU资源和时间？如果我是查找一个关键字，那么时间更加可观，因为前面的搜索可以限定在一个很小的范围内，比如用户权限只查用户表，帖子内容只查帖子表，
    而且查到就可以马上停止查询，而搜索肯定会对所有的数据进行一次判断，消耗的时间是相当的大。
    CC就是充分利用了这个特点，模拟多个用户（多少线程就是多少用户）不停的进行访问（访问那些需要大量数据操作，就是需要大量CPU时间的页面）.
   这一点用一个一般的性能测试软件就可以做到大量模拟用户并发。
   防御CC攻击可以通过多种方法，比如，可以分析攻击的请求头信息，分析它的特点，然后针对这些请求做一些限制。
   也可以分析请求的ip，利用iptables来限制ip。将网站做成静态页面，也可以有效降低服务器资源使用。另外，还可以限制连接数量，修改最大超时时间等。

2） ddos攻击的方式有很多种，最基本的ddos攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。
    单一的ddos攻击一般是采用一对一方式的，当攻击目标CPU速度低、内存小或者网络带宽小等等各项指标不高的性能，它的效果是明显的。
    随着计算机与网络技术的发展，计算机的处理能力迅速增长，内存大大增加，同时也出现了千兆级别的网络，
    这使得DoS攻击的困难程度加大了-目标对恶意攻击包的"消化能力"加强了不少。这时候分布式的拒绝服务攻击手段（ddos）就应运而生了。
    ddos就是利用更多的傀儡机（肉鸡）来发起进攻，以比从前更大的规模来进攻受害者。
    简单的ddos，比如cc，我们可以通过限定ip来解决攻击。但有时候攻击量很大，甚至可以把机房的网络攻击瘫痪，这时候只能临时在上层网络把目标IP封掉，
    这样牺牲单个ip而保全大局。此外也可以隐藏服务器外网地址，服务器前端加 CDN 中转来防止ddos攻击。



案例：
建立一个名为index.html的文件，并使其root不可写。
答案：
[root@localhost ~]# touch index.html
[root@localhost ~]# chattr +i index.html 
[root@localhost ~]# lsattr index.html 
----i--------e- index.html
[root@localhost ~]# chattr -i index.html 
[root@localhost ~]# lsattr index.html 
-------------e- index.html

案例：
Linux Shell可否实现多线程处理？
答案：
可以实现多线程。其实就是把要执行的命令丢到后台去，同时运行它们。比如，正常执行一个shell脚本是一条命令执行完成后再执行下一条命令。
那如果把所有命令后面加个&，让它丢到后台去运行，则所有的命令会同时执行完。

案例：
网站HTTPS证书认证需要那几个文件？分别是什么？什么作用？
答案：
HTTPS证书需要有两个文件，一个是crt，一个是key。crt文件就是证书，用来加密的。而key文件是私钥文件，是用来解密的。

案例：
请简述CDN原理。CDN实际是全局负载均衡+智能DNS解析+缓存系统的一个综合应用

1) 用户向浏览器提供要访问的域名；
2) 浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录，为了得到实际IP地址，
   浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。
3) 此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求；
4) 缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求；
5) 缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，另一方面把获取的数据返回给客户端，完成数据服务过程；
6) 客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。
通过以上的分析我们可以得到，为了实现既要对普通用户透明(即加入缓存以后用户客户端无需进行任何设置，直接使用被加速网站原有的域名即可访问，
又要在为指定的网站提供加速服务的同时降低对ICP的影响，只要修改整个访问过程中的域名解析部分，以实现透明的加速服务。


CDN主要应用于图片和静态资源，动态资源不适合做缓存
企业级的CDN服务商：蓝汛，网宿，帝联



案例：
构建简单lnmp网站架构模型（corosync不能对负载均衡做高可用，所以要用到keepalived或者heartbeat中的ldirectord）
设备：13台服务器，要求：有负载均衡和数据库主从
答案：
架构：Keepavlied + lvs + nginx/php + NFS + mysql + redis
2台主机：keepalived+lvs 
5台主机：Nginx+php-fpm
1台主机：NFS 
2台主机：Mysql双主，并使用keepalived构建高可用
1台主机：Redis用来存session
1台主机：备份机器
1台主机：监控机器


案例：
说一下公司多少台服务器，是什么架构
答案：有7台服务器，lnmp+nginx负载均衡+keepalived，
2台主机：keepalived+lvs
2台主机：nginx/php-fpm
2台主机：mysql（一主一从）
1台主机：NFS（上面兼着跑监控、备份）


案例：
每天早上6点到12点，每隔2小时执行一次/usr/bin/httpd.sh怎么实现
答：crontab -e 
0 6,8,10,12 * * * /bin/bash /usr/bin/httpd.sh

案例：
网站做了负载均衡，发现有些用户访问的时候经常需要重新登录，是什么原因，怎么处理？
答：
这是因为用户登录后，他的请求被分发到了另外一台服务器上。
默认情况下服务保存用户的session是在/tmp/下面，本来已经在A服务器上保存了session，可下次访问到了B服务器，而B服务器又不存在刚才保存的session信息，所以就会显示未登录。
要解决这个问题很容易，比较简单的做法是，做一个会话保持。比如可以设定1小时内用户的请求固定在一台服务器上。
如果是nginx也可以设置ip_hash。当然最好的解决方案是，使用redis存取session，实现session共享。


案例：
linux引导加载的先后顺序是BIOS kernel GRUB MBR RAID？
答案：BIOS -> RAID -> MBR -> GRUB -> kernel

案例：
进程间通信方式主要有哪几种方式？
答案：1管道 2命名管道 3信号 4消息队列 5共享内存 6信号量 7套接字

案例：
简要说明你对内核空间和用户空间的理解？
答案：操作系统和驱动程序运行在内核空间，应用程序运行在用户空间
详细请参考http://www.go-gddq.com/html/QianRuShiXiTong-JiShu/2012-07/1031748.htm

案例：
文件描述符FD的数量与TCP连接数有什么关系？
答案：
对于服务器来讲，每一个连接到本机上面的tcp连接都要产生一个socket，每一个socket就是一个文件描述符。所以tcp连接数和文件描述符是一样的。

案例:
在tcp应用中，server事先在某个固定端口监听，client主动发起连接，经过三路握手后建立tcp连接。那么对单机，其最大并发tcp连接数是多少？

系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。
client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享---重要
tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，
最大tcp连接数为65535，这些连接可以连到不同的server ip。（注意这个说的是client，也就是客户端）

server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，
因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，
不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。

上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。
在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），
另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。

对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万是没问题的，国外 Urban Airship 公司在产品环境中已做到 50 万并发 。
在实际应用中，对大规模网络应用，还需要考虑C10K 问题。

案例：
linux主机的cpu负载使用，什么情况下user的比例升高，什么情况下system的比例升高，请联系实际举例。
答案：
在Linux系统里面跑的用户安装服务比较忙的时候，会导致user的比例升高，比如mysql服务、php服务等。
同样，当进程比较忙，比如php使用非常频繁，子进程非常多的时候，会导致进程切换频繁，system的比例就会升高。



案例：
不小心在系统下执行了chmod -x /bin/chmod 怎么办？
答案：
/lib64/ld-linux-x86-64.so.2 /bin/chmod +x /bin/chmod   64位
/lib/ld-linux-x86-64.so.2 /bin/chmod +x /bin/chmod     32位


案例：
Buffer和Cache的区别
1、buffer缓冲是为了提高内存和硬盘（或其他I/O设备）之间的数据交换的速度而设计的。
   缓冲是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。
   linux有一个守护进程定期清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。
   buffer是由各种进程分配的，被用在如输入队列等方面。
   一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存。
2、cache（缓存），从CPU角度考虑，是为了提高cpu和内存之间的数据交换速度而设计的，例如平常见到的一级缓存、二级缓存、三级缓存。 
   cache经常被用在磁盘的I/O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能。
   cache并不是缓存文件的，而是缓存块的(块是I/O读写最小的单元)
简单来说，buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的。

expect介绍：
Expect是一个用来处理交互的命令。借助Expect，我们可以将交互过程写在一个脚本上，使之自动化完成。形象的说，ssh登录，ftp登录等都符合交互的定义
Expect中最关键的是如下4个命令
         send：用于向进程发送字符串
       expect：从进程接收字符串
        spawn：启动新的进程
     interact：允许用户交互

实际上expect也可以接受参数
案例：
不需要输入密码即可连入对方主机的操作步骤
[root@localhost tmp]# yum install -y expect 
[root@localhost tmp]# vim test.exp
#!/usr/bin/expect
spawn ssh root@192.168.139.136
expect  "(yes/no)?" { send "yes\n" }        提示输入yes
expect  "password:" { send "chenhao@\n" }   提示输入密码
interact
[root@localhost tmp]# expect test.exp
如果此时把ssh root@192.168.139.136替换为复制公钥给对方，则后续就可以实现基于密钥的认证登录
案例：
ssh从A自动登录到B，然后从B自动登录到c
#!/usr/bin/expect 
set timeout 30
spawn ssh codfei@B
expect "password:"
send "pppppp\n"
expect "]*"
send "ssh codfei@C\n"
expect "password:"
send "pppppp\n"
interact


案例：
   rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，
   这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。 rsync是一个功能非常强大的工具，其命令也有很多功能特色选项，
   rsync [OPTION]... SRC DEST   
   拷贝本地文件。当SRC和DES路径信息都不包含有单个冒号":"分隔符时就启动这种工作模式。
   如：rsync -a /data /backup 使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。
   rsync [OPTION]... SRC [USER@]host:DEST  
   使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当DST路径地址包含单个冒号":"分隔符时启动该模式。如：rsync -avz *.c foo:src
   rsync [OPTION]... [USER@]HOST:SRC DEST  
   使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当SRC地址路径包含单个冒号":"分隔符时启动该模式。如：rsync -avz foo:src/bar /data
   rsync [OPTION]... [USER@]HOST::SRC DEST 
   rsync [OPTION]... SRC [USER@]HOST::DEST 
   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
详细参考鸟哥基础篇746页

案例:
    假设apache的日志文件为access_log，在apache正在运行时，执行命令mv access_log access_log.bak，执行完成后，请问新的apache的日志会打印到哪里？为什么？
    答案：
    新的日志会打印在access_log.bak中，因为apache启动时会找到access_log文件，随时准备向文件中加入日志信息，
    虽然此时文件名被改变，但是由于服务正在进行，因为它的inode节点的位置没有变，程序打开的fd任然会指向原来那个inode
    不会因为文件名的改变而改变，apache会继续向已经改名的文件中追加日志。但是如果重启服务，系统则会检查access_log文件是否存在，如果不存在就创建

案例:
如果得到一个随机的字符串，长度和字符串中出现的字符表可自定义，并将字符串颠倒显示，
如把0123456789做为基准的字符串字符表，产生一个6位的字符串642031，则打印出来的字符串为130246
[root@localhost tmp]# awk -v count=6 'BEGIN{srand();str="012345678";len=length(str);for(i=count;i>0;i--)marry[i]=substr(str,int(rand()*len),1);
                             for(i=0;i<=count;i++)printf("%c",marry[i]);printf("\n");
                             for(i=count;i>0;i--)printf("%c",marry[i]);printf("\n")}'
605500
005506


案例：颠倒字符串
[root@localhost ~]# a='hello'
[root@localhost ~]# echo $a|rev
olleh


案例：把分区使用率超过20%的发邮件告知出来
先要配置好基于无密钥登录远程主机的环境
[root@localhost ~]# vim fs.sh 
#!/bin/bash
#
FSMAX="20"
remote_user='root'                                                      
remote_ip=(127.0.0.1 192.168.139.184)                         
a=${#remote_ip[@]}
for i in $(seq 0 $[ $a-1 ]);do
    ssh "$remote_user"@"${remote_ip[$i]}" df -h > /tmp/diskcheck_tmp
    grep '^/dev/*' /tmp/diskcheck_tmp|awk '{print $5}'|sed 's/\%//g' > /tmp/diskcheck_num_tmp
    b=$(wc -l /tmp/diskcheck_num_tmp|awk '{print $1}')
    for k in $(seq 1 $b);do
        size=$(sed -n "$k"'p' /tmp/diskcheck_num_tmp)
        if [ "$size" -gt "$FSMAX" ];then
             $(grep '^/dev/*' /tmp/diskcheck_tmp|sed -n $k'p' > /tmp/disk_check_mail)
             $(echo ${remote_ip[$i]} >> /tmp/disk_check_mail)
             $(cat /tmp/disk_check_mail|mail -s "diskcheck_alert" root@localhost)
        fi
    done
done

[root@localhost ~]# crontab -e 每10分钟执行一次脚本
0/10 * * * * /root/fs.sh 2>&1

案例：
阻止 IP 欺骗：IP 欺骗会让人认为某个来自于外部的某个数据包是来自于它到达的那个接口。这一技术常被骇客(cracker)所使用。您可以让内核阻止这种入侵。请键入：
echo 1 >/proc/sys/net/ipv4/conf/all/rp_filter   这样ip欺骗攻击就不再可能了

案例：打印每一行的第一个字母
[root@node3 ~]# vim  test.txt 
sdfkjsdkf
34ur849u
ncxvmdklf
[root@node3 ~]# awk -F '' '{print $1}' test.txt 
s
3
n




案例：
一个EXT3 的文件分区，当使用touch test.file 命令创建一个新文件时报错，报错的信息是提示磁盘已满，但是采用df -h命令查看磁盘大小时，只使用了60%的磁盘空间，
为什么会出现这个情况，说说你的理由。
答：两种情况，
    一种是磁盘配额问题
    一种就是EXT3 文件系统的设计不适合，导致有很多小文件时，容易导致inode 耗尽了

案例：
RIP协议即Routing Information Protocol路由信息协议，是最为普遍的一种内部协议，一般称为动态路由信息协议
详细参考鸟哥网络篇239页


案例：
在1-39内取随机数
[root@localhost tmp]# echo $[$RANDOM%36]
33


案例：
如何查看二进制文件的内容
使用od命令，详细参考鸟哥基础篇178页


案例：
计算每一个httpd进程占用的平均内存
[root@localhost tmp]# ps aux|grep httpd|grep -v grep |awk '{sum+=$6;n++};END{print sum/n}' 
2600.44

172.16.0.0/255.255.0.0; 自动获取；

	cmd: ipconfig/all; 

	VNC: Virtual Network Computing，协议；

		TigerVNC, RealVNC

		C/S：Server, Client

		vncviewer: client
		vncserver: server

		URL:    ftp://172.16.0.1/pub

Server：172.16.0.1, 192.168.0.254, 192.168.1.254
	
	桌面共享：172.16.100.1；
			  172.16.200.1;

	ftp服务， ftp://172.16.0.1
	http服务，http://172.16.0.1
		/cobbler
		/centos
	dhcp服务：
		172.16.250.X
		172.16.249.X

		172.16.X.1-254
			X: 学号；
		172.16.100+X.1-254

	http://www.slideshare.net, twitter

	Windows：x64,
		32bits: 2^32 = 4G (3.25G)

上课纪律：
	1、不要迟到；俯卧撑，1分钟两个；
	2、不要请假：超出3天；
	3、不要在教学区抽烟；
	4、不准做与学习无关的事情，尤其是游戏；
	5、上课手机铃声不能响，一次30个俯卧撑；
	6、用电安全；
	7、睡觉：前后左右同学俯卧撑；30个；

作业：两周以后的知识留存率
	主动学习：
		动手实践：40%；
		讲给别人：70%;
			写博客：5w1h
				what, why, when, where, who
				how
			提问：
	被动学习：
		听课：10%;
		笔记：20%；

分组：项目实践；

上课时间：
	上午：8:30-12:20
	下午：14:30-18:20

Linux运维课程体系大纲：重要
第一阶段：
	Linux入门；
	Linux系统管理；
	Linux服务及安全管理；
		httpd, lamp, lnmp
		Cache：memcached, varnish
		DB: mysql (mariadb)
	Linux Cluster：
		LB Cluster：Nginx, LVS,haproxy 
		HA Cluster：Keepalived, Corosync+Pacemaker+pcs/crmsh,heartbeat
	Linux Ops：ansible
	Monitoring：zabbix
	shell脚本编程
第二阶段：
		tomcat, lnmt, lamt, session replication cluster
		分布式存储系统：MogileFS, GlusterFS		
		MySQL：HA Cluster、MHA、备份和恢复、MySQL Replcation、Read-Write splitting
		NoSQL：redis, mongodb, HBase
		运维工具：puppet [saltstack], cobbler
		虚拟化：
			Linux操作系统原理；虚拟化技术原理；
			kvm虚拟化应用详解；xen虚拟化；
			虚拟化网络：SDN
			OpenStack云栈
		Docker,容器云(比如k8s)
		ELK Stack：ElasticSearch, Logstash, Kibana
		大数据：Hadoop v2, 并行存储及分析平台；
			HBase, Hive
			Storm, Spark
		系统优化：
		Python编程,目标是掌握基本语法


	RedHat：
		认证考试：
			RHCSA
			RHCE
			RHCA
	学习阶段：
		教室学习：4个月；
		工作学习：8个月，14个月；

IT技术领域：
	研发：
		硬件：接口；
			CPU（运算器和控制器），内存，输入，输出；
				冯 诺依曼
			机器语言：二进制指令，二进制数据

		软件：
			低级语言：汇编语言，汇编器
				写驱动；
			高级语言：
				系统级：C，C++，
					操作系统，对性能要求较高的服务类程序
				应用级：Java, Python, ruby
					应用程序：ansible, puppet, ....

	应用：
		Linux运维：Linux生态圈中的各应用程序的应用；
			shell脚本编程：让某些应用工作能自动完成；
			Python：专业编程语言；
				ansible, openstack

		DevOps: 
			Development
			Operations

计算机与操作系统

	ENIARC: 
		CPU：运算器、控制器、寄存器、缓存
		存储器：内存，RAM(Random Access Memory)	
		Input：下指令，提供数据等；
		Output：输出数据加工的结果；

	程序可以理解为如下两种思想：
        指令+数据
	算法+数据结构

	2^10=1024
		1024*1024*1024*4 Bytes
			1024*1024*4 KB
			1024*4 MB
			4 GB

	过程式编程语言：
		顺序执行：依次
		循环执行：将整个循环体执行n次；
		选择执行：仅执行其中的一个分支；

	多任务：multi tasks
		Bell, MIT, GE = Multics

		Ken Thompson：Space Travel

		DEC: PDP-11, VAX(VMS)
			PDP-7: 汇编语言

			1969: Unics = unix

			Unix：1971, nroff,

			1972：unix, 10台；

			B: Dennis Ritch, C

		《美国计算机通信》：1974，第一次公之于众；

		AT&T：System V7, 1979

		1978: SCO
		1980: Microsoft, XENIX

		Berkeley：Ken, Berkeley,
			Bill Joy, BSRG，1977, BSD(Berkeley System Distribution)

		1980，DARPA，TCP/IP,

		1981年：Microsoft, Bill Gates
			SCP: QDOS(Quick and Dirty Operating System)
			windows
			windows nt(new technology)

			DOS 2.0, CP/M

			1990: unix

		SUN: Bill Joy
			workstation

		Apple：
			XEROX: PARK(star)

		1985：Richard Stallman
			GNU: GNU is Not Unix.
				GPL: General Public License
				FSF：Free Software Foundation

				X-Window: GPL
				gcc: gnu c complier
				vi: visual interface
				... ...

				free: freedom

		Unix：
			SUN: Solaris
			IBM: AIX
			HP: HP-UX

	Andrew：Minix, 4000+行

		System V Unix <--> BSD

		1990：BSD，
			Jolitz, BSD, x86

			386-BSD

		1991年8月：Linus Torvalds宣布成立Linux；
			GPL

		Larry Wall, diff, patch

	完整的OS:
		Kernel+Application
		狭义上的OS: kernel
		GNU/Linux,linux本质来说就是kernel
	大教堂式，集市， www.top500.org; 
	OS的接口有两类：
		GUI：Graphic User Interface
			GNome：c开发, 基于gtk开发库开发
			KDE: c++, qt
		CLI：Command Line Interface    cat /etc/shells可以查看本机支持的shell种类
			bash
			zsh
			sh
			csh
			tcsh
			ksh
	操作系统的功能：
		驱动程序
		进程管理
		安全
		网络功能
		内存管理
		文件系统
		.......

	API: Application Program Interface
		程序员编程时需要调用的编程接口
		POSIX: Portable Operating System 可移植操作系统
	ABI: Application Binary Interface
		程序应用者面对运行程序的接口,比如都是二进制可执行文件，windows是exe格式，linux是elf格式

	GNU：
		源码：编译成为 二进制格式

			gcc, glibc, vi, linux

		发行版：数百种之多；发行商就是把大部分开源软件的代码编译成二进制然后打包提供给用户
			Debian
				ubuntu
			        mint
				knopix
			Slackware
				S.u.S.E
					SLES
					OpenSUSE
			RedHat:
				Redhat 9.0:
					RedHat Enterprise Linux: RHEL
				        CentOS: Community ENTerprise OS
					Fedora Core：6个月，
			Gentoo
			ArchLinux
	软件程序：版本号；
		major.minor.release
			Linux：0.99, 2.2, 2.4, 2.6, 3.0, 4.0
				www.kernel.org
			GNU:
				vi
				gcc

	发行版本也有自己的版本号：
		RHEL: 5.x, 6.x, 7.x
			Fedora 23
		Debian：8.x
		OpenSuSE: 13.x 

	课外作业：
		GPL, BSD, Apache
		Android

回顾：
	Debian, Slackware, RedHat
		Debian：
			Ubuntu
			Knopix
		Slackware:
			S.u.S.E
				OpenSUSE
		RedHat：
			Fedora
			CentOS

		Linux：内核
			Application

			GNU/Linux：通常以源码（文本格式）方式提供；
				自由、灵活；

		Gentoo
		ArchLinux

Linux基础：

	CPU架构：
		x86
		x64 (amd64)
		m68000, m68k
		arm
		ultrasparc solaris
		power aix
		powerpc, ppc
		MIPS
		alpha hp-ux
		...

	POS: POSIX
		API: Application Program Interface

	ABI：Application Binary Interface

	Linux, BSD, AIX, ...: Unix-like
		Unix类的系统：
			API
			ABI

	Stallman: GNU
		闭源：
		开源：提供源代码；
			开源协定：
				GPL：General Public License
					copyright, copyleft

					LGPL：Lesser GPL
					GPLv2, GPLv3

					FSF：Free 
				BSD：
				Apache：
					ASF：Apache Software Foundation
			双线授权：
				Community：遵循开源协定；
				Enterprise：
	程序管理：
		程序的组成部分：
			二进制程序；
			配置文件；
			库文件；
			帮助文件；
		X, Y, Z
		程序包管理器：
			X：
				程序的组成文件打包成一个或有限几个文件；
				安装：
				卸载；
				查询；
		Debian：deb, apt-get
		RedHat：rpm, yum后续会升级为dnf
		S.u.S.E: rpm, zypper
		ArchLinux：port
		Gentoo：
		LFS: Linux From Scratch 从零开始构建linux
		kali：
	安装Linux：从本质来说，操作系统已经把硬件虚拟化了
		虚拟机：Linux
			计算机：CPU, 内存, IO(IO的虚拟化是通过emulation来实现)
		虚拟化软件程序：
			vmware workstation
			virtualbox
	CentOS的镜像站点：
		http://mirrors.aliyun.com
		http://mirrors.163.com
		http://mirrors.sohu.com
	在教室安装的系统：
		Cobbler：
			硬盘大小：120G
			网卡：桥接
		管理员：root/mageedu
        locale命令可以查看语言环境
	ISO镜像：
		硬盘分区：留出一些空间；实在不成，可安装完成以后，新增一块虚拟硬盘；		
	终端：terminal

		用户界面：
			GUI：
				GNome
				KDE
			CLI：
				bash, zsh, sh, csh, tcsh, ksh

		远程连接：
			ssh协议：secure shell;
				~]# ss -tnl
					查看系统是否监听于tcp协议的22号端口；
				~]# ip addr list
				或
				~]# ifconfig

					查看IP地址；

				确保防火墙处于关闭状态：
					~]# iptables -L -n

					CentOS 7:
						~]# systemctl disable firewalld.service
						~]# systemctl stop firewalld.service

					CentOS 6：
						~]# service iptables stop
						~]# chkconfig iptables off

	终端设备：terminal
		多任务、多用户
		物理终端，控制台：console
		虚拟终端：6个，tty
			Ctrl+Alt+F[1-6]
		图形终端：
			CentOS 6:
				Ctrl+Alt+F7
			CentOS 7：
				在哪个虚拟终端启动，即位于哪个虚拟终端；
		串行终端：ttyS
		伪终端：pty,也就是通过ssh服务远程连接进去的情况
		Linux的哲学思想之一：一切皆文件；
			表现之一：硬件设备也通过文件表示；
				物理终端：/dev/console
				虚拟终端：/dev/tty# [1,6]
				串行终端：/dev/ttyS# 
				伪终端：/dev/pts/#
		注意：在启动设备之后，在其上关联一个用户接口程序，即可实现与用户交互；
			查看终端设备：
				~]# tty
			查看接口程序：
				~]# echo $SHELL
			启动GUI:
				在某一虚拟终端接口运行命令：startx &，注意是虚拟终端，在伪终端是不能启动startx的

	CLI接口：
		命令行接口：
			[root@node1 ~]# COMMAND
				prompt：
					root: 当登录的用户
					node1: 当前主机的主机名，非完整格式；此处的完整格式为：node1.magedu.com
					~：用户当前所在的目录(current directory)，也称为工作目录(working directory)；相对路径；
					#：命令提示符；
						#：管理员账号，为root; 拥有最高权限，能执行所有操作；
						$：普通用户，非root用户；不具有管理权限，不能执行系统管理类操作；

					注意：建议使用非管理员账号登录；
						执行管理操作临时切换至管理员，操作完成即退回；

	几个基础命令：
		tty：查看当前的终端设备；
		ifconfig或ip addr list：查看活动接口的ip地址；
		echo：回显
		ping：探测网络的目标主机与当前主机之间的连通性；
			Ctrl+c：终止命令执行；

		关机命令：
			CentOS 7：
				~]# systemctl poweroff
				~]# systemctl reboot

			*：
				~]# poweroff
				~]# halt
				~]# reboot

	Stallman: 
		自由含义：自由学习和修改；自由使用；自由分发；自由创建衍生版；

	Linux的哲学思想：
		1、一切皆文件：
			把几乎所有资源统统抽象为文件形式；包括硬件设备，甚至通信接口等；
				open(), read(), write(), close(), delete(), create()
		2、	由众多功能单一的程序组成；一个程序只做一件事，并且做好；
			组合小程序完成复杂任务；
		3、尽量避免跟用户交互；
			目标：易于以编程的方式实现自动化任务；
		4、使用文本文件保存配置信息；
	思考：文件是什么？众多文件如何有效组织起来？
		目录：路径映射；
		文件：存储空间存储的一段流式数据，对数据可以做到按名存取；
		文件系统：层级结构；有索引；
			/: 原初起点；				
				倒置树状结构；
				/dev/pts/2:
					最左侧/: 表示根目录
					其它的/: 表示路径分隔符
						Linux的路径分隔符是/
						Windows的是\
			文件的路径表示：
				绝对路径：从根开始表示出的路径 
				相对路径：从当前位置开始表示出的路径
			文件名使用法则：
				严格区分字符大小写：file1, File1, FILE1
				目录也是文件，在同一路径下，两个文件不能同名；
				支持使用除/以外的任意字符；
				最长不能超过255个字符；
			用户有家目录：home,
				用户的起始目录；普通用户管理文件的位置；
			工作目录：
				/etc/sysconfig/network-scripts/ifcfg-eno16777736
					basename：最右侧的文件或目录名；
					dirname：basename左侧的路径；
				命令：
					~]# basename /PATH/TO/SOMEFILE
						SOMEFILE
					~]# dirname /PATH/TO/SOMEFILE
						/PATH/TO

回顾：
	
	开源协定：
		GPL，LGPL，BSD, Apache

	BSD：
		1、如果二次发布的产品中包含源代码，则在源代码中必须带有原来的代码中的BSD协定；
		2、如果二次发布产品是二进制格式的库或程序，则需要在发布的文档或版权声明中说明包含原来的代码中的BSD协定；
		3、不可以用开源代码的作者或组织，以及原来的产品的名字做市场推广；

	代码的共产的义运动；

	文件系统、文件、目录：
		倒置树状结构：
			目录；
			文件；

		文件名：严格区分字符大小写；路径分隔符/；

	路径：
		绝对路径
		相对路径

	程序的组成部分：二进制程序文件、库文件、配置文件、帮助文件；
		二进制、库文件：可执行文件
			库文件：不能独立执行，只能被调用时执行
		配置文件、帮助文件：可被查看其内容的文件

		《穿越计算机的迷雾》、《量子物理史话》

	人机交互界面：
		GUI
		CLI
			[login@hostname workdir]# COMMAND

Linux基础知识

	命令的语法通用格式：
		# COMMAND OPTIONS ARGUMENTS
		COMMAND: 
			发起一命令：请求内核将某个二进制程序运行为一个进程；
				程序 --> 进程
				静态 --> 动态（有生命周期）

			命令本身是一个可执行的程序文件：二进制格式的文件，有可能会调用共享库文件；
				多数系统程序文件都存放在：/bin, /sbin, /usr/bin, /usr/sbin，/usr/local/bin, /usr/local/sbin
					普通命令：/bin, /usr/bin, /usr/local/bin
					管理命令：/sbin, /usr/sbin, /usr/local/sbin
				共享库：/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64
					32bits的库：/lib, /usr/lib, /usr/local/lib
					64bits的库：/lib64, /usr/lib64, /usr/local/lib64

				注意：并非所有的命令都有一个在某目录与之对应的可执行程序文件，因为还有内置命令

			命令必须遵循特定格式规范：exe, msi, ELF(Linux)
				~]# file /bin/lst
			命令分为两类：
				由shell程序的自带的命令：内置命令(builtin),内置命令是没有可执行程序文件的
				独立的可执行程序文件，文件名即命令名：外部命令
			shell程序是独特的程序，负责解析用户提供的命令；
				环境变量：
					PATH：从哪些路径中查找用户键入的命令字符串所对应的命令文件；
						~]# echo $PATH
						/usr/lib64/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
						查找次序：自左而右；
			查看命令类型：
				type COMMAND

		OPTIONS：
			指定命令的运行特性；
			选项有两种表现形式：
				短选项：-C, 例如-l, -d
					注意：有些命令的选项没有-；
					如果同一命令同时使用多个短选项，多数可合并：-l -d = -ld
				长选项：--word, 例如--help, --human-readable
					注意：长选项不能合并；
				注意：有些选项可以带参数，此称为选项参数；

		ARGUMENTS：
			命令的作用对象；命令对什么生效；
			注意：不同的命令的参数；有些命令可同时带多个参数，多个之间以空白字符分隔；
		例如：ls -ld /var /etc 

	获取命令的使用帮助：
		内部命令：
			help COMMAND
		外部命令：
			(1) 命令自带简要格式的使用帮助
				# COMMAND --help
			(2) 使用手册：manual
				位置：/usr/share/man
				# man COMMAND
					SECTION：
						NAME：功能性说明
						SYNOPSIS：语法格式
						DESCRIPTION：描述
						OPTIONS：选项
						EXAMPLES：使用示例
						AUTHOR: 作者
						BUGS: 报告程序bug的方式
						SEE ALSO: 参考
						...

					SYNOPSIS: 
						[]：可选内容；
						<>：必须提供的内容；
						a|b|c：多选一；
						...：同类内容可出现多个；

				使用手册：压缩格式的文件，有章节之分，也就是把一个命令的帮助文档切割成几个部分分别存放
					/usr/share/man/
						man1, man2, ...
						1：用户命令；
						2：系统调用；
						3：C库调用；
						4：设备文件及特殊文件；
						5：文件格式；（配置文件格式）
						6：游戏使用帮助；
						7：杂项；
						8：管理工具及守护进行；
					~]# man CHAPTER COMMAND  不加chapter直接执行man command时出现command在1-8中的第一个出现的部分
					注意：并非每个COMMAND在所有章节下都有手册；
					查看：
					~]# whatis COMMAND 查看对应命令在哪些chapter有帮助文档
					注意：其执行过程是查询数据库进行的；
					手动更新数据库：
					~]# makewhatis 更新数据库需要一段时间（centos6有该命令，7已结没有了）
				man命令打开手册以后的操作方法：
					翻屏：
						空格键：向文件尾翻一屏；
						b: 向文件首部翻一屏；
						Ctrl+d：向文件尾部翻半屏；
						Ctrl+u：向文件首部翻半屏；
						回车键：向文件尾部翻一行；
						k: 向文件首部翻一行；
						G：跳转至最后一行；
						#G: 跳转至指定行；
						1G：跳转至文件首部；

					文本搜索：
						/keyword：从文件首部向文件尾部依次查找；不区分字符大小写；
						?keyword：从文件尾部向文件首部依次查找；	
							n: 与查找命令方向相同的方向查看后续文档；
							N: 与查找命令方向相反的方向查看后续文档

					退出：
						q: quit

				选项：
			        man -M /PATH/TO/SOMEDIR：到指定目录下查找命令手册并打开之；

				练习：获取useradd命令的用法
					(1) 添加用户gentoo；
						# useradd gentoo
						# id gentoo
					(2) 添加用户slackware，要求指定其所用的shell为/bin/tcsh；
						# useradd -s /bin/tcsh slackware
						# tail -1 /etc/passwd

			(3) info COMMAND
				获取命令的在线文档；
			(4) 很多应用程序会自带帮助文档：/usr/share/doc/APP-VERSION
				README：程序的相关的信息；
				INSTALL: 安装帮助；
				CHANGES：版本迭代时的改动信息；

			(5) 主流发行版官方文档
				http://www.redhat.com/doc

			(6) 程序官方的文档：
				官方站点上的“Document”

			(7) 搜索引擎google
					keyword filetype:pdf
					keyword site:domain.tld
					...
		书籍的出版社：
			O'Reiley
			Wrox
			机械工业、电子工业、人邮、清华大学、水利水电
	常用命令：
		Linux文件系统：
			1、文件名名称严格区分字符大小写；
			2、文件可以使用除/以外任意字符；
			3、文件名长度不能超过255字符；
			4、以.开头的文件为隐藏文件；
				.: 当前目录；
				..: 当前目录的上一级目录；
					/etc/sysconfig/
						.: sysconfig
						..: /etc

		工作目录：working directory
		家目录：home

		常用命令：
			pwd: printing working directory
				显示工作目录

			cd：change directory
				cd [/PATH/TO/SOMEDIR]	
					cd: 切换回家目录；
						注意：bash中, ~表示家目录；
					cd ~：切换回自己的家目录
					cd ~USERNAME：切换至指定用户的家目录；
					cd -：在上一次所在目录与当前目录之间来回切换；
						相关的环境变量
							$PWD：当前工作目录
							$OLDPWD：上一次的工作目录

					.
					..

			ls: list, 列出指定目录下的内容
				ls [OPTION]... [FILE]...

					-a: 显示所有文件，包括隐藏文件；
					-A：显示除.和..之外的所有文件；
					-l: --long, 长格式列表，即显示文件的详细属性信息；
						-rw-r--r--. 1 root   root     8957 10月 14 19:34 boot.log
						-：文件类型，-, d, b, c, l, s, p
						rw-r--r--
							rw-：文件属主的权限；
							r--：文件属组的权限；
							r--：其它用户（非属主、属组）的权限；
						1：数字表示文件被硬链接的次数；
						root：文件的属主；
						root：文件的属组；
						8957：数字表示文件的大小，单位是字节；
						10月 14 19:34 ：文件最近一次被修改的时间；
						boot.log：文件名
					-h, --human-readable：对文件大小单位换算；换算后结果可能会非精确值；
					-d：查看目录自身而非其内部的文件列表；
					-r: reverse, 逆序显示；
					-R: recursive，递归显示；
                                        -i：显示inode

			cat：concatenate
				文件文本查看工具；
					cat /etc/fstab
					cat /etc/passwd

				cat [OPTION]... [FILE]...
					-n：给显示的文本行编号；
					-E: 显示行结束符$；

			tac：
				文件文本查看工具；
					tac /etc/fstab
					tac /etc/passwd

				tac [OPTION]... [FILE]...
					-n：给显示的文本行编号；
					-E: 显示行结束符$；

			file：查看文件内容类型；
				file [FILE]...

			echo：回显
				echo [SHORT-OPTION]... [STRING]...	
					-n: 不进行换行；
					-e：让转义符生效；
						\n：换行
						\t：制表符，即表示横向空格
                                                \v: 纵向空格符
                          举例：echo -e  'hello\tworld' 
                                hello	world

					STRING可以使用引号，单引号和双引号均可用；
						单引号：强引用，变量引用不执行替换；
							~]# echo '$SHELL'
						双引号：弱引用，变量引用会被替换；
							~]# echo "$SHELL"

				注意：变量引用的正规符号是${name}

			关机或重启命令：shutdown
				shutdown [OPTIONS...] [TIME] [WALL...]
					OPTIONS:
						-h: halt
						-r：reboot
						-c：cancel

					TIME：
						now
						hh:mm
						+m
							+0

					WALL

			日期相关的命令：
				Linux：系统启动时从硬件读取日期和时间信息；读取完成以后，就不再与硬件相关联；
					系统时钟
					硬件时钟
				
				date：系统时钟 
					显示日期时间：date [OPTION]... [+FORMAT]
						FORMAT：格式符
                                                 %m   month (01..12)
                                                 %M   minute (00..59)
                                                 %H   hour (00..23)
                                                 %I   hour (01..12)
                                                 %s   seconds since 1970-01-01 00:00:00  UTC 从1970年1月1号(unix元年)0点0分0秒到命令执行那一刻经过的秒数；
                                                 %S   second (00..60)
                                                 date --help 
举例：
[root@localhost ~]# date +%F 
2017-10-05
[root@localhost ~]# date +%Y-%m-%d-%H:%M:%S 
2017-10-05-06:44:17
[root@u03userdata03 log]# date   +%Y%m%d
20180628
[root@u03userdata03 log]# date -d "5 day ago"  +%Y%m%d
20180623
                           

				hwclock, clock：硬件时钟
hwclock  --help 
Usage:hwclock [function] [option...]
Functions:
 -s, --hctosys        set the system time from the hardware clock         以硬件为准，把系统调整为与硬件时间相同；
 -w, --systohc        set the hardware clock from the current system time 以系统为准，把硬件时间调整为与系统时钟相同；

				

				cal：日历
					 cal [[month] year]

		课外作业：
			which, whereis, who, w

回顾：

	如何获取使用帮助：
		help 
		--help, man, info
		自带文档(README, CHANGELOG, INSTALL), 官方文档
		发行版的文档
		Google

		Linux Kerenl: Documentation

		manual：使用手册
			whatis keyword
			man # KEYWORD

				SECTION:
					NAME
					SYNOPSIS
						[], <>, |, {}, ...
					...

				控制命令：
					Space, b
					Enter, k
					Ctrl+d, Ctrl+u
					q
					#G

					/keyword
					?keyword
						n
						N

	基础命令：pwd, cd, ls, echo, date, clock, cal, hwclock, cat, tac, file, type, tty, halt, poweroff, shutdown, reboot

Linux文件系统：

	Linux：glibc
	
		程序编译方式：
			动态链接
			静态编译

	进程的类型：
		终端：硬件设备，关联一个用户接口
		与终端相关：通过终端启动
		与终端无关：操作引导启动过程当中自动启动

	操作系统的组成：
		静态：kernel, application
		文件系统：层级结构

	FHS仅定义了如下3个目录应该放什么数据：
                /:与开机系统有关
                /usr：与软件安装和执行有关
                /var：与系统运作有关
        如下5个目录必须与/(即根目录）在同一个分区：
                /sbin，/dev，/lib，/etc，/bin

		Filesystem Hierarchy Standard
			/bin：所有用户可用的基本命令程序文件；
			/sbin：供系统管理使用的工具程序；
			/boot：引导加载器必须用到的各静态文件：kernel, initramfs(initrd), grub等；
			/dev：存储特殊文件或设备文件；
				设备有两种类型：字符设备(线性设备)、块设备(随机设备)；
			/etc：系统程序的配置文件，只能为静态；
			/home：普通的家目录的集中位置；一般每个普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME；
			/root：管理员的家目录；可选；
			/lib：为系统启动或根文件系统上的应用程序(/bin, /sbin等)提供共享库，以及为内核提供内核模块
				libc.so.*：动态链接的C库；
				ld*：运行时链接器/加载器；
				modules：用于存储内核模块的目录；
			/lib64：64位系统特有的存放64位共享库的路径；
			/media：便携式设备挂载点，cdrom, floppy等；
			/mnt：其它文件系统的临时挂载点；
			/opt：附加应用程序的安装位置；可选路径；
			/srv：当前主机为服务提供的数据；
			/tmp：为那些会产生临时文件的程序提供的用于存储临时文件的目录；可供所用户执行写入操作；有特殊权限；
			/usr：usr Hierarchy，全局共享的只读数据路径；usr表示unix software resource 
				bin, sbin
				lib, lib64
				include：C程序头文件；
				share：命令手册页和自带文档等架构特有的文件的存储位置
				local：另一个层级目录；
				X11R6：X-Window程序的安装位置
				src：程序源码文件的存储位置
			/usr/local：Local hierarchy，让系统管理员安装本地应用程序；也通常用于安装第三方程序；
			/var：/var Hierarchy，存储常发生变化的数据的目录；
				cache	Application cache data
				lib		Variable state information
				local	Variable data for /usr/local
				lock	Lock files
				log		Log files and directories
				opt		Variable data for /opt
				run		Data relevant to running processes
				spool	Application spool data
				tmp		Temporary files preserved between system reboots	

			/proc：基于内存的虚拟文件系统，用于为内核及进程存储其相关信息；它们多为内核参数，例如net.ipv4.ip_forward, 虚拟为net/ipv4/ip_forward,
                               存储于/proc/sys/, 因此其完整路径为/proc/sys/net/ipv4/ip_forward；
			/sys：sysfs虚拟文件系统提供了一种比proc更为理想的访问内核数据的途径；其主要作用在于为管理Linux设备提供一种统一模型的的接口；
                        参考：https://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/

	Linux系统上的文件类型：
		-：常规文件；即f；
		d: directory，目录文件；
		b: block device，块设备文件，支持以“block”为单位进行随机访问
		c：character device，字符设备文件，支持以“character”为单位进行线性访问
			major number：主设备号，用于标识设备类型，进而确定要加载的驱动程序
			minor number：次设备号，用于标识同一类型中的不同的设备；
				8位二进制：0-255
		l：symbolic link，符号链接文件；
		p: pipe，命名管道；
		s: socket，套接字文件；

	基本命令：
		命令类型：
			外部命令
			shell内嵌命令

			type COMMAND：
				内部：builtin
				外部：显示为命令文件路径；
					注意：命令可以有别名；别名可以与原名相同，此时原名被隐藏；此时如果要运行原命令，则使用\COMMAND；

			命令别名：
				获取所有可用别名的定义：
					~]# alias
				定义别名：
					~]# alias NAME='COMMAND'
					注意：仅对当前shell进程有效
				撤销别名：
					~]# unalias NAME

		which命令：
			which - shows the full path of (shell) commands

			which [options] programname [...]
				--skip-alias：忽略别名
         举例： which corosync-keygen 
               /usr/sbin/corosync-keygen

		whereis命令：
			whereis - locate the binary, source, and manual page files for a command

			whereis [options] name...
				-b: 仅搜索二进制程序路径；
				-m：仅搜索使用手册文件路径；
         举例：whereis  corosync-keygen 
               corosync-keygen: /usr/sbin/corosync-keygen /usr/share/man/man8/corosync-keygen.8.gz

		who命令：
			who - show who is logged on

			 who [OPTION]...
			 	-b: 系统此次启动的时间；
			 	-r: 运行级别；

		w命令：
			w - Show who is logged on and what they are doing.




	bash的基础特性之一：

		命令历史：shell进程会其会话中保存此前用户提交执行过的命令；
			~]# history
				定制history的功能，可通过环境变量实现：
					HISTSIZE：shell进程可保留的命令历史的条数；
					HISTFILE：持久保存命令历史的文件；
						  .bash_history
					HISTFILESIZE：命令历史文件的大小；

			命令用法：
				history [-c] [-d 偏移量] [n] 
				或 history -anrw [文件名] 
				或 history -ps 参数 [参数...]

				-c: 清空命令历史；
				-d offset：删除指定命令历史
				-r: 从文件读取命令历史至历史列表中；
				-w：把历史列表中的命令追加至历史文件中；
				history #：显示最近的#条命令；

			调用命令历史列表中的命令：
				!#：再一次执行历史列表中的第#条命令；
				!!：再一次执行上一条命令；
				!STRING：再一次执行命令历史列表中最近一个以STRING开头的命令；

					注意：命令的重复执行有时候需要依赖于幂等性；

			调用上一条命令的最后一个参数：
				快捷键：ESC, .
				字符串：!$

			控制命令历史记录的方式：
				环境变量：HISTCONTROL
					ignoredups：忽略重复的命令；
					ignorespace：忽略以空白字符开头的命令；
					ignoreboth：以上两者同时生效；

				修改变量的值：
					NAME='VALUE'

	《奇点临近》

回顾：
	
	FHS、命令及bash命令历史
		FHS：
			/bin, /sbin, /lib, /lib64, /etc 
			/home, /root
			/boot
			/media, /mnt
			/proc, /sys
			/tmp
			/srv
			/opt
			/dev
			/usr
				bin, sbin, lib, lib64, share, local, include, ...
			/var
				cache, lib, log, ...

		命令：which, whereis, who, w, alias, unalias
		命令历史：history
		文件类型：-, d, b, c, l, p, s



3-3
Linux基础知识

	bash的基础特性：

		命令补全：
			shell程序在接收到用户执行命令的请求，分析完成之后，最左侧的字符串会被当作命令；
			命令查找机制：
				查找内部命令；
				根据PATH环境变量中设定的目录，自左而右逐个搜索目录下的文件名；

			给定的打头字符串如果能惟一标识某命令程序文件，则直接补全；
			                    不能惟一标识某命令程序文件，再击tab键一次，会给出列表；

		路径补全：
			在给定的起始路径下，以对应路径下的打头字串来逐一匹配起始路径下的每个文件：
				tab：
					如果能惟一标识，则直接补全；
					否则，再一次tab，给出列表；

	目录管理类的命令：
		mkdir, rmdir

		mkdir：make directories

			mkdir [OPTION]... DIRECTORY...
				-p: 自动按需创建父目录；
				-v: verbose，显示详细过程；
				-m MODE：直接给定权限；

				注意：路径基名方为命令的作用对象；基名之前的路径必须得存在；

		rmdir：remove empty directories

			rmdir [OPTION]... DIRECTORY...

				-p：删除某目录后，如果其父目录为空，则一并删除之；
				-v: 显示过程；

		问题1：如何创建/tmp/x/y1, /tmp/x/y2, /tmp/x/y1/a, /tmp/x/y1/b？
		问题2：如何创建a_c, a_d, b_c, b_d；

	bash的基础特性之：命令行展开
		~：自动展开为用户的家目录，或指定的用户的家目录；			
		{}：可承载一个以逗号分隔的路径列表，并能够将其展开为多个路径；
			例如：/tmp/{a,b} 相当于 /tmp/a /tmp/b

		问题1：mkdir -pv /tmp/x/{y1/{a,b},y2}
		问题2：mkdir -v {a,b}_{c,d}

		问题3：创建如下目录结构：
			/tmp/mysysroot/
				|-- bin
				|-- etc
				|   `-- sysconfig
				|       `-- network-scripts
				|-- sbin
				|-- usr
				|   |-- bin
				|   |-- lib
				|   |-- lib64
				|   |-- local
				|   |   |-- bin
				|   |   |-- etc
				|   |   |-- lib
				|   |   `-- sbin
				|   `-- sbin
				`-- var
				    |-- cache
				    |-- log
				    `-- run

			~]# mkdir -pv /tmp/mysysroot/{bin,sbin,etc/sysconfig/network-scripts,usr/{bin,sbin,local/{bin,sbin,etc,lib},lib,lib64},var/{cache,log,run}}

	tree命令：需要自己安装
		tree [options] [directory]
			-L level：指定要显示的层级；

	bash的基础特性：命令的执行状态结果

		命令执行的状态结果：
			bash通过状态返回值来输出此结果：
				成功：0
				失败：1-255

			命令执行完成之后，其状态返回值保存于bash的特殊变量$?中；

		命令正常执行时，有的还回有命令返回值：
			根据命令及其功能不同，结果各不相同；

		引用命令的执行结果：
			$(COMMAND)或`COMMAND`

	bash的基于特性：引用
		强引用：''
		弱引用：""
		命令引用：``

	bash基础特性：快捷键
		Ctrl+a：跳转至命令行行首
		Ctrl+e：跳转至命令行行尾

		Ctrl+u：删除行首至光标所在处之间的所有字符；
		Ctrl+k：删除光标所在处至行尾的所有字符；

		Ctrl+l：清屏，相当于clear


3-4

	文件查看类命令：cat, tac, head, tail, more, less

		分屏查看命令：more和less

		more命令：
			more FILE
				特点：翻屏至文件尾部后自动退出；

		less命令：
			less FILE

		head命令：
			查看文件的前n行；
				head [options] FILE
					-n #
					-#   两种方式都可以

		tail命令：
			查看文件的后n行；
				tail [options] FILE
					-n #
					-#
					-f：查看文件尾部内容结束后不退出，跟随显示新增的行；

		stat命令：
			stat - display file or file system status

			stat FILE...

			文件：两类数据
				元数据：metadata
				数据: data

举例如下
[root@node4 ~]# stat install.log 
File: `install.log'
Size: 53023     	Blocks: 112        IO Block: 4096   regular file
Device: 802h/2050d	Inode: 261123      Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2017-05-15 05:49:38.824999942 +0800
Modify: 2017-05-15 06:11:48.041999572 +0800
Change: 2017-05-15 06:12:09.728999593 +0800
文件有3个timestamps
mtime：文件内容被改变时，会更新该时间。ll命令默认显示出来的就是mtime
ctime:文件的状态，如属性，权限被改变时，会更新该时间
atime:当文件的内容被读取时，会更新该时间

		touch命令：用于修改文件时间或者创建新文件
			touch - change file timestamps

			touch [OPTION]... FILE...
				-c: 指定的文件路径不存在时不予创建；
				-a: 仅修改access time；
				-m：仅修改modify time；
				-t STAMP 只能修改atime和mtime，ctime不能修改
					[[CC]YY]MMDDhhmm[.ss]

具体时间查看方式
[root@node4 ~]# ll anaconda-ks.cfg ;ll --time=atime anaconda-ks.cfg ;ll --time=ctime anaconda-ks.cfg 
-rw-------. 1 root root 1463 May 15 06:11 anaconda-ks.cfg
-rw-------. 1 root root 1463 May 15 06:11 anaconda-ks.cfg
-rw-------. 1 root root 1463 May 15 06:12 anaconda-ks.cfg




	文件管理工具：cp, mv, rm

		cp命令：copy
			源文件；目标文件；

	       单源复制：cp [OPTION]... [-T] SOURCE DEST
	       多源复制：cp [OPTION]... SOURCE... DIRECTORY
	       			 cp [OPTION]... -t DIRECTORY SOURCE...

	       	单源复制：cp [OPTION]... [-T] SOURCE DEST
	       		如果DEST不存在：则事先创建此文件，并复制源文件的数据流至DEST中；
	       		如果DEST存在：
	       			如果DEST是非目录文件：则覆盖目标文件；
	       			如果DEST是目录文件：则先在DEST目录下创建一个与源文件同名的文件，并复制其数据流；

	       	多源复制：cp [OPTION]... SOURCE... DIRECTORY
	       			  cp [OPTION]... -t DIRECTORY SOURCE...

	       		如果DEST不存在：错误；
	       		如果DEST存在：
	       			如果DEST是非目录文件：错误；
	       			如果DEST是目录文件：分别复制每个文件至目标目录中，并保持原名；

	       	常用选项：
	       		-i：交互式复制，即覆盖之前提醒用户确认；
	       		-f：强制覆盖目标文件；
	       		-r, -R：递归复制目录；
	       		-d：复制符号链接文件本身，而非其指向的源文件；
	       		-a：-dR --preserve=all, archive，用于实现归档；-a选项把所有属性一起复制过来
	       		--preserv=
	       			mode：权限
	       			ownership：属主和属组
	       			timestamps: 时间戳
	       			context：安全标签
	       			xattr：扩展属性
	       			links：符号链接
	       			all：上述所有属性

	    mv命令：move
	       mv [OPTION]... [-T] SOURCE DEST
	       mv [OPTION]... SOURCE... DIRECTORY
	       mv [OPTION]... -t DIRECTORY SOURCE..	    	

	       常用选项：
	       		-i：交互式；
	       		-f：force

	    rm命令：remove
	    	rm [OPTION]... FILE...

	    	常用选项：
	    		-i：interactive
	    		-f：force
	    		-r: recursive

	    		删除目录：rm -rf /PATH/TO/DIR
	    			危险操作：rm -rf /*

	    	注意：所有不用的文件建议不要直接删除，而是移动至某个专用目录；（模拟回收站）

	变量：
		命名的内存空间；
			变量类型：
				字符型：
				数值型
					精确数值：
					近似数值：

				存储格式、数据范围、参与运算；

				课外作业：浮点数据如何存储？单精度，双精度？

		变量的赋值操作：
			name=tom

回顾：
	bash基础特性：命令补全、路径补全、命令引用
	文件或目录的复制、移动、删除
	变量：变量类型
		存储格式、数据范围、参与运算

3-4 
bash的基础特性：

	globbing：文件名通配(整体文件名匹配，而非部分)

		匹配模式：元字符
			*：匹配任意长度的任意字符
				pa*, *pa*, *pa, *p*a*
					pa, paa, passwd
			?：匹配任意单个字符
				pa?, ??pa, p?a, p?a?
					pa, paa, passwd
			[]：匹配指定范围内的任意单个字符
				有几种特殊格式：
					[a-z], [A-Z], [0-9], [a-z0-9]
					[[:upper:]]：所有大写字母
					[[:lower:]]：所有小写字母
					[[:alpha:]]：所有字母
					[[:digit:]]：所有数字
					[[:alnum:]]：所有的字母和数字
					[[:space:]]：所有空白字符
					[[:punct:]]：所有标点符号

					pa[0-9][0-9], 2[0-9][0-9]
			[^]：匹配指定范围外的任意单个字符
				[^[:upper:]]
				[^0-9]
				[^[:alnum:]]

		练习1：显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现一位任意字符的文件或目录；
			ls -d /var/l?[[:lower:]]

		练习2：显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录； 
			ls -d /etc/[0-9]*[^0-9]

		练习3：显示/etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录；
			ls -d /etc/[^a-z][a-z]*

		练习4：复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/magedu.com目录；
			cp -r /etc/m*[^0-9] /tmp/magedu.com/

		练习5：复制/usr/share/man目录下，所有以man开头，后跟一个数字结尾的文件或目录至/tmp/man/目录下；
			cp -r /usr/share/man/man[0-9] /tmp/man/

		练习6：复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d/目录下；
			cp -r /etc/[mnrp]*.conf /tmp/conf.d/

	IO重定向及管道

		程序：指令+数据
			程序：IO

			可用于输入的设备：文件
				键盘设备、文件系统上的常规文件、网卡等；
			可用于输出的设备：文件
				显示器、文件系统上的常规文件、网卡等；

			程序的数据流有三种：
				输入的数据流；<-- 标准输入(stdin)，键盘；
				输出的数据流：--> 标准输出(stdout)，显示器；
				错误输出流：  --> 错误输出(stderr)，显示器；

			fd: file descriptor，文件描述符
				标准输入：0
				标准输出：1
				错误输出：2

		IO重定向：

			输出重定向：>
				特性：覆盖输出
			输出重定向：>>
				特性：追加输出

			# set -C
				禁止覆盖输出重定向至已存在的文件；
				此时可使用强制覆盖输出：>|
			# set +C
				关闭上述特性

			错误输出流重定向：2>, 2>>

			合并正常输出流和错误输出流：
				(1) &>, &>>
				(2) COMMAND > /path/to/somefile 2>&1
				    COMMAND >> /path/to/somefile 2>&1

				特殊设备：/dev/null

			输入重定向：<

			tr命令：
				tr [OPTION]... SET1 [SET2]
					把输入的数据当中的字符，凡是在SET1定义范围内出现的，通通对位转换为SET2出现的字符

				用法1：把SET1字符串替换为SET2
					tr SET1 SET2 < /PATH/FROM/SOMEFILE
				用法2：删除文本中的SET1字符串
					tr -d SET1 < /PATH/FROM/SOMEFILE

				注意：不修改原文件
举例：
[root@node4 ~]# tr fstab  FASTAB  < /etc/fstab  
#
# /eSc/FASTA
# CreTSed Ay TnTcondT on Mon MTy 15 05:49:38 2017
#
# AcceAAiAle FileAyASemA, Ay reFerence, Tre mTinSTined under '/dev/diAk'
# See mTn pTgeA FASTA(5), FindFA(8), mounS(8) Tnd/or Alkid(8) For more inFo
#
UUID=8cA8062F-4d88-445F-98dc-0038d28ccT1d /                       exS4    deFTulSA        1 1
UUID=Fe2e3dT9-21Ac-4Fd4-840e-2ddd51060AF7 /AooS                   exS4    deFTulSA        1 2
UUID=18e8cAAT-Td10-432F-A12A-5295A12A89dF AwTp                    AwTp    deFTulSA        0 0
SmpFA                   /dev/Ahm                SmpFA   deFTulSA        0 0
devpSA                  /dev/pSA                devpSA  gid=5,mode=620  0 0
AyAFA                   /AyA                    AyAFA   deFTulSA        0 0
proc                    /proc                   proc    deFTulSA        0 0



Here Document：<<  两个小于符号表示结束输入的意思
cat << EOF
cat > /PATH/TO/SOMEFILE << EOF

举例如下
[root@node4 ~]# cat > test.ext <<EOF
> hello world 
> nihao 
> EOF
[root@node4 ~]# cat test.ext 
hello world 
nihao 

			管道：连接程序，实现将前一个命令的输出直接定向后一个程序当作输入数据流
				COMMAND1 | COMMAND2 | COMMAND3 | ...

				tee命令：表示双向重定向
					COMMAND | tee /PATH/TO/SOMEFILE
举例如下
[root@node4 ~]# cat test.ext |tee t.ext 
hello world 
nihao 
[root@node4 ~]# cat t.ext 
hello world 
nihao 

			练习1：把/etc/passwd文件的前6行的信息转换为大写字符后输出；
				head -n 6 /etc/passwd | tr 'a-z' 'A-Z'

		命令总结：tr, tee


	用户、组和权限管理

		Multi-tasks, Multi-Users

		每个使用者：
			用户标识、密码；
				Authentication
				Authorization
				Audition

			组：用户组，用户容器

		用户类别：
			管理员
			普通用户
				系统用户
				登录用户

			用户标识：UserID, UID
				16bits二进制数字：0-65535
					管理员：0
					普通用户：1-65635
						系统用户：1-499(CentOS6), 1-999(CentOS7)
						登录用户：500-60000(CentOS6), 1000-60000(CentOS7)

				名称解析：名称转换
					Username <--> UID

					根据名称解析库进行：/etc/passwd

		组：
			组类别1：
				管理员组
				普通用户组
					系统组
					登录组

			组标识：GroupID, GID
				管理员组：0
					普通用户组：1-65635
						系统用户组：1-499(CentOS6), 1-999(CentOS7)
						登录用户组：500-60000(CentOS6), 1000-60000(CentOS7)	

			名称解析：groupname <--> gid
				解析库：/etc/group	

			组类别2：
				用户的基本组
				用户的附加组

			组类别3:
				私有组：组名同用户名，且只包含一个用户；
				公共组：组内包含了多个用户；

		认证信息：
			通过比对事先存储的，与登录时提供的信息是否一致；
			password：
				/etc/shadow
				/etc/gshadow

			密码的使用策略：
				1、使用随机密码；
				2、最短长度不要低于8位；
				3、应该使用大写字母、小写字母、数字和标点符号四类字符中至少三类；
				4、定期更换；

			加密算法：
				对称加密：加密和解密使用同一个密码；
				非对称加密：加密和解密使用的一对儿密钥；
					密钥对儿：
						公钥：public key
						私钥: private key
				单向加密：只能加密，不能解密；提取数据特征码；
					定长输出
					雪崩效应

					算法：
						md5: message digest, 128bits
						sha：secure hash algorithm安全hash算法, 160bits
						sha224
						sha256
						sha384
						sha512

					在计算之时加salt，添加的随机数；

		/etc/passwd：用户的信息库
			name:password:UID:GID:GECOS:directory:shell

			name: 用户名
			password：可以是加密的密码，也可是占位符x；
			UID：
			GID：用户所属的主组的ID号；
			GECOS：注释信息
			directory：用户的家目录；
			shell：用户的默认shell，登录时默认shell程序；

		/etc/shadow：用户密码
			用户名:加密的密码:最近一次修改密码的时间:最短使用期限:最长使用期限:警告期段:过期期限:保留字段

		/etc/group：组的信息库
			group_name:password:GID:user_list

				user_list：该组的用户成员；以此组为附加组的用户的用户列表；

	相关命令：useradd, userdel, usermod, passwd, groupadd, groupdel, groupmod, gpasswd, chage, chsh, id, su

回顾：
	bash globing, IO重定向及管道
		glob：*, ?, [], [^]
		IO重定向：
			>, >>
			2>, 2>>
			&>, &>>
			> /PATH/TO/SOMEWHERE 2>&1
			<, <<(Here Document)
			COMMAND1 | COMMAND2
			命令：tr, tee
	用户管理基础概念：
		用户类别：
			管理员、普通用户（系统用户和登录用户）
		组类别：
			管理员组、普通用户组
			基本组和附加组
			私有组、公共组
		数据库文件：
			/etc/passwd
				login:password:uid:gid:comment:home:shell
			/etc/shadow
				login:encrpted_password:...
			/etc/group
				group:password:gid:user_list

			密码存储格式：单向加密，并借助于salt完成
				1: md5
				sha1
				sha224
				sha256
				sha384
				6: sha512

Linux用户和组管理

	安装上下文：--重要
		进程以其发起者的身份运行；
                进程对文件的访问权限，取决于发起此进程的用户的权限；

	系统用户：为了能够让那后台进程或服务类进程以非管理员的身份运行，通常需要为此创建多个普通用户；这类用户从不用登录系统；


	groupadd命令：添加组

		groupadd [选项] group_name

			-g GID：指定GID；默认是上一个组的GID+1；
			-r: 创建系统组；

	groupmod命令：修改组属性

		groupmod [选项] GROUP
			-g GID：修改GID；
			-n new_name：修改组名；

	groupdel命令：删除组

		groupdel [选项] GROUP

	useradd命令：创建用户

		useradd [选项] 登录名
			-u, --uid UID：指定UID；
			-g, --gid GROUP：指定基本组ID，此组得事先存在；
			-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]：指明用户所属的附加组，多个组之间用逗号分隔；
			-c, --comment COMMENT：指明注释信息；
			-d, --home HOME_DIR：以指定的路径为用户的家目录；通过复制/etc/skel此目录并重命名实现，目录里面都是隐藏文件；指定的家目录路径如果事先存在，
                                             则不会为用户复制环境配置文件；
			-s, --shell SHELL：指定用户的默认shell，可用的所有shell列表存储在/etc/shells文件中；
			-r, --system：创建系统用户，系统用户也意味则不会创建家目录
                        -M, --no-create-home        不创建用户的家目录


		注意：创建用户时的诸多默认设定配置文件为/etc/login.defs	

		useradd -D：显示创建用户的默认配置；--重要
		useradd -D 选项: 修改默认选项的值；
                修改的结果保存于/etc/default/useradd文件中；

	usermod命令：修改用户属性

		usermod [选项] 登录
			-u, --uid UID：修改用户的ID为此处指定的新UID；
			-g, --gid GROUP：修改用户所属的基本组；
			-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]：修改用户所属的附加组；原来的附加组会被覆盖；
			-a, --append：与-G一同使用，用于为用户追加新的附加组；
			-c, --comment COMMENT：修改注释信息；
			-d, --home HOME_DIR：修改用户的家目录；用户原有的文件不会被转移至新位置；
			-m, --move-home：只能与-d选项一同使用，用于将原来的家目录移动为新的家目录；
			-l, --login NEW_LOGIN：修改用户名；
			-s, --shell SHELL：修改用户的默认shell；

			-L, --lock：锁定用户密码；即在用户原来的密码字符串之前添加一个"!"；
			-U, --unlock：解锁用户的密码；
举例如下
[root@node2 ~]# usermod -c 'hello' chenhao 
[root@node2 ~]# cat /etc/passwd|grep chenhao 
chenhao:x:1000:1000:hello:/home/chenhao:/bin/bash


	userdel命令：删除用户

		userdel [选项] 登录
			-r：删除用户时一并删除其家目录；

	练习1：创建用户gentoo，UID为4001，基本组为gentoo，附加组为distro(GID为5000)和peguin(GID为5001)；
	练习2：创建用户fedora，其注释信息为"Fedora Core"，默认shell为/bin/tcsh；

	练习3：修改gentoo用户的家目录为/var/tmp/gentoo；要求其原有文件仍能被用户访问；
	练习4：为gentoo新增附加组netadmin；
               usermod -a -G netadim gentoo，因为是新增所以要加-a

	passwd命令：
		passwd [-k] [-l] [-u [-f]] [-d] [-e] [-n mindays] [-x maxdays] [-w warndays] [-i inactivedays] [-S] [--stdin] [username]

		(1) passwd：修改用户自己的密码；
		(2) passwd USERNAME：修改指定用户的密码，但仅root有此权限；

			-l, -u：锁定和解锁用户；
			-d：清除用户密码串；
			-e DATE: 过期期限，日期；
			-i DAYS：非活动期限；
			-n DAYS：密码的最短使用期限；
			-x DAYS：密码的最长使用期限；
			-w DAYS：警告期限；

			--stdin：
				echo "PASSWORD" | passwd --stdin USERNAME

	gpasswd命令：

		组密码文件：/etc/gshadow

		gpasswd [选项] group
			-a USERNAME：向组中添加用户
			-d USERNAME：从组中移除用户

	newgrp命令：临时切换指定的组为基本组；只能针对当前的用户进行

		newgrp [-] [group]

			-: 会模拟用户重新登录以实现重新初始化其工作环境；

	chage命令：更改用户密码过期信息

		chage [选项] 登录名

			-d
			-E
			-W
			-m
			-M

	id命令：显示用户的真和有效ID; 

		id [OPTION]... [USER]
			-u: 仅显示有效的UID；
			-g: 仅显示用户的基本组ID; 
			-G：仅显示用户所属的所有组的ID；
			-n: 显示名字而非ID；

	su命令：switch user
		登录式切换：会通过读取目标用户的配置文件来重新初始化
			su - USERNAME
			su -l USERNAME
		非登录式切换：不会读取目标用户的配置文件进行初始化
			su USERNAME

		注意：管理员可无密码切换至其它任何用户；

		-c 'COMMAND'：仅以指定用户的身份运行此处指定的命令；
举例如下
[chenhao@node2 ~]$ su -l root -c 'cat /etc/fstab' 
Password: 输入密码
#
# /etc/fstab
# Created by anaconda on Thu Jun  8 07:26:58 2017
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos-root /                       xfs     defaults        0 0
UUID=6f7208ca-e486-4628-b268-27b49d712db2 /boot                   xfs     defaults        0 0
/dev/mapper/centos-swap swap                    swap    defaults        0 0


	其它几个命令：chsh, chfn, finger, whoami, pwck, grpck

	命令总结：groupadd, groupmod, groupdel, useradd, usermod, userdel, passwd, gpasswd, newgrp（修改临时组为基本组）, id, su, chage



su需要了解新切换用户的密码（经常是root用户的密码），而sudo的执行仅需要自己的密码即可，甚至可以不需要密码也可以执行
25-5
sudo:execute a command as another user
配置文件：/etc/sudoers
配置文件里面可以定义两类内容：
       （1）别名的定义，即变量
       （2）授权项，可用别名进行授权
每一行格式如下：
who where=(run as) commands
1）who表示用户账号，即有哪些用户账号可以使用sudo命令，其有如下表示方式
   username
   #uid
   %groupname  表示用户组
   %#gid
   user-alias
2）run as表示可以切换的用户，其表示方式和who一样
3）where表示登录者的来源主机名，有如下表示方式：
    单个ip或hostname
    Netaddr
    Host-alias
4）commands：命令必须使用绝对路径

定义别名的方法：
    ALIAS_TYPE  NAME=item1,item2,....

    ALIAS_TYPE有如下表示方式：
              User_Alias
              Host_Alias
              Runas_Alias
              Cmnd_Alias
    NAME:别名的名称字母必须使用全大写字母
    常用标签：NOPASSWD,PASSWD,比如NOPASSWD: ALL等

sudo [option] commands
     -u username 以指定的用户身份运行命令，如果没有此项默认表示切换的身份为root
     -l          列出用户能以sudo执行的命令



案例：
系统刚开始默认仅有root能使用sudo命令
[root@localhost ~]# sudo -u sshd touch /tmp/test.txt   
[root@localhost ~]# ll /tmp/test.txt 
-rw-r--r-- 1 sshd sshd 0 Oct  5 17:49 /tmp/test.txt
说明：sshd是系统用户，其shell是/sbin/nologin,所以无法执行su -l sshd，但是使用上述的sudo命令就可以

案例：
修改配置文件使chenhao用户可以切换到root用户，且无需密码
[root@localhost ~]# visudo
 chenhao        ALL=(root)       NOPASSWD: ALL
[chenhao@localhost ~]$ sudo -l                                查看用用户可以以sudo执行的命令
User chenhao may run the following commands on this host:
    (root) NOPASSWD: ALL 
[chenhao@localhost ~]$ ls -l  /root                           直接以chenhao用户来查看root目录就会被拒绝
ls: cannot open directory /root: Permission denied
[chenhao@localhost ~]$ sudo ls -l  /root                       加了sudo可以顺利执行

案例：
用户别名的使用，且不能修改root用户的密码
[root@localhost ~]# visudo
User_Alias USERADMIN=chenhao
Cmnd_Alias ADMINCMND=!/usr/bin/passwd root,! /usr/bin/passwd,/usr/bin/passwd  [A-Za-z]*
USERADMIN  ALL=(root)  NOPASSWD:ADMINCMND
[chenhao@localhost ~]$ sudo -l 
User chenhao may run the following commands on this host:
    (root) NOPASSWD: !/usr/bin/passwd root, !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*
[chenhao@localhost ~]$ sudo passwd                              修改root密码不可以
Sorry, user chenhao is not allowed to execute '/usr/bin/passwd' as root on localhost.localdomain.
[chenhao@localhost ~]$ sudo passwd chenhao1                     修改chenhao1密码可以

案例：
sudo和su命令的搭配使用
[root@localhost ~]# visudo
User_Alias USERADMIN=chenhao
USERADMIN  ALL=(root)  NOPASSWD:/bin/su -
[root@localhost ~]# sudo su - 此时执行这条命令就可以切换成为root用户了，但是切换成root用户后，就可以修改root密码了，怎么解决呢？

补充案例：
剔除掉线上的一个用户
[root@localhost ~]# w
 18:28:08 up  1:10,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.139.1    17:37    0.00s  0.17s  0.09s w
chenhao  pts/1    192.168.139.1    17:38   10.00s  0.05s  0.05s -bash
[root@localhost ~]# pkill -kill -t pts/1
[root@localhost ~]# w
 18:36:37 up  1:18,  1 user,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.139.1    17:37    0.00s  0.08s  0.00s w


	权限管理：
		ls -l 
			rwxrwxrwx:
				左三位：定义user(owner)的权限
				中三位：定义group的权限；
				右三位：定义other的权限

		进程安全上下文：
			进程对文件的访问权限应用模型：
				进程的属主与文件的属主是否相同；如果相同，则应用属主权限；
				否则，则检查进程的属主是否属于文件的属组；如果是，则应用属组权限；
				否则，就只能应用other的权限；

		权限：
			r：readable, 读
			w：writable, 写
			x：excutable，执行

			文件：
				r：可获取文件的数据；
				w: 可修改文件的数据；
				x：可将此文件运行为进程；

			目录：
				r：可使用ls命令获取其下的所有文件列表；
				w: 可修改此目录下的文件列表；即创建或删除文件；
				x: 可cd至此目录中，且可使用ls -l来获取所有文件的详细属性信息；

			mode：rwxrwxrwx
			ownership：user, group

		权限组合机制：
			--- 000 0
			--x 001 1
			-w- 010 2
			-wx 011 3
			r-- 100 4
			r-x 101 5
			rw- 110 6
			rwx 111 7

		练习：rw-rw-r--, rwxrwxr-x, rwxr-x---, rw------, rwxr-xr-x
			  664, 640, 600, 775, 750, 755

		权限管理命令：
			chmod命令：
		       chmod [OPTION]... MODE[,MODE]... FILE...
		       chmod [OPTION]... OCTAL-MODE FILE...
		       chmod [OPTION]... --reference=RFILE FILE...

		       三类用户：
		       		u：属主
		       		g：属组
		       		o：其它
		       		a: 所有

		       (1) chmod [OPTION]... MODE[,MODE]... FILE...

		       		MODE表示法：
		       			赋权表示法：直接操作一类用户的所有权限位rwx；
		       				u=
		       				g=
		       				o=
		       				a=

		       			授权表示法：直接操作一类用户的一个权限位r,w,x；
		       				u+, u-
		       				g+, g-
		       				o+, o-
		       				a+, a-

		       	(2) chmod [OPTION]... OCTAL-MODE FILE...

		       	(3) chmod [OPTION]... --reference=RFILE FILE...

		       	选项：
		       		-R, --recursive：递归修改

		       	注意：用户仅能修改属主为自己的那些文件的权限；

		从属关系管理命令：chown, chgrp

			chown命令：
				chown [OPTION]... [OWNER][:[GROUP]] FILE...
        		chown [OPTION]... --reference=RFILE FILE...

        		选项：
        			-R：递归修改

        	chgrp命令：

       			chgrp [OPTION]... GROUP FILE...
       			chgrp [OPTION]... --reference=RFILE FILE...

       		注意：仅管理员可修改文件的属主和属组；

       	思考：用户对目录有写权限，但对目录下的文件没有写权限时，能否修改此文件内容？能否删除此文件？
       	      模拟之；

       	umask：文件的权限反向掩码，遮罩码；
       		文件：
       			666-umask
       		目录：
       			777-umask

       		注意：之所以文件用666去减，表示文件默认不能拥有执行权限；如果减得的结果中有执行权限，则需要将其加1；
       			umask: 023
       				666-023=644 为了保证没有错误，执行按位操作
       				777-023=754

       		umask命令：
       			umask：查看当前umask
       			umask MASK: 设置umask

       		注意：此类设定仅对当前shell进程有效；

       	练习：完成以下任务
       		1、新建系统组mariadb, 新建系统用户mariadb, 属于mariadb组，要求其没有家目录，且shell为/sbin/nologin；尝试root切换至用户，查看其命令提示符；
       		2、新建GID为5000的组mageedu，新建用户gentoo，要求其家目录为/users/gentoo，密码同用户名；
       		3、新建用户fedora，其家目录为/users/fedora，密码同用户名；
       		4、新建用户www, 其家目录为/users/www；删除www用户，但保留其家目录；
       		5、为用户gentoo和fedora新增附加组mageedu; 
       		6、复制目录/var/log至/tmp/目录，修改/tmp/log及其内部的所有文件的属组为mageedu，并让属组对目录本身拥有写权限；

    install命令：很少使用
    	install - copy files and set attributes

    	单源复制：
       		install [OPTION]... [-T] SOURCE DEST
       	多源复制：
       		install [OPTION]... SOURCE... DIRECTORY
       		install [OPTION]... -t DIRECTORY SOURCE...
       	创建目录：
       		install [OPTION]... -d DIRECTORY...

       	常用选项：
       		-m, --mode=MODE：设定目标文件权限，默认为755；
       		-o, --owner=OWNER：设定目标文件属主；
       		-g, --group=GROUP：设定目标文件属组；

    mktemp命令：
    	mktemp - create a temporary file or directory

    	mktemp [OPTION]... [TEMPLATE]

    		常用选项：
    			-d：创建临时目录

    	注意：mktemp会将创建的临时文件名直接返回，因此，可直接通过命令引用保存起来；

    博客作业：用户及权限管理


回顾：用户管理、权限管理、install、mktemp

	用户管理：
	权限管理：
		mode, ownership
		mode:
			user
			group
			other

			r
			w
			x

	命令：install, mktemp(.XXX)

5-2

bash特性及bash脚本编程初步

	终端，附着在终端的接口程序：
		GUI：KDE, GNome, Xfce
		CLI：/etc/shells,这个文件内容标注了本机支持哪些shells
			bash
			zsh
			fish

	bash的特性：
		命令行展开：~, {}
		命令别名：alias, unalias
		命令历史：history
		文件名通配：glob
		快捷键：Ctrl+a, e, u, k, l
		命令补全：$PATH
		路径补全：

	bash特性之：命令hash
		缓存此前命令的查找结果：key-value
			key：搜索键
			value：值

		hash命令：
			hash：列出
			hash -d COMMAND：删除
			hash -r：清空

	bash的特性之：变量
		程序：指令+数据
			指令：由程序文件提供；
			数据：IO设备、文件、管道、变量

		程序：算法+数据结构

		变量名+指向的内存空间

		变量赋值：name=value
		变量类型：存储格式、表示数据范围、参与的运算
			编程语言：
				强类型变量
				弱类型变量：
					bash把所有变量统统视作字符型；
					bash中的变量无需事先声明；相当于，把声明和赋值过程同时实现；（重要）
						声明：类型，变量名
		变量替换：把变量名出现的位置替换为其所指向的内存空间中数据；
		变量引用：${var_name}, $var_name，两者都可以
		变量名：变量名只能包含数字、字母和下划线，而且不能以数字开头；
			变量名：见名知义，命名机制遵循某种法则；不能够使用程序的保留字，例如if, else, then, while等等；
				
		bash变量类型：
                        环境变量：作用域为当前shell进程及其子进程；
			本地变量：作用域仅为当前shell进程；
			局部变量：作用域仅为某代码片断(函数上下文)；
                        位置参数变量：当执行脚本的shell进程传递的参数；
			特殊变量：shell内置的有特殊功用的变量；
				$?：
					0：成功
					1-255：失败

			本地变量：
				变量赋值：name=value
				变量引用：${name}, $name
					""：变量名会替换为其值；
					''：变量名不会替换为其值；
				查看变量：set
				撤销变量：unset name 注意：此处非变量引用，所以无需在name前加$

			环境变量：
				变量赋值：
					(1) export name=value
					(2) name=value
					    export name
					(3) declare -x name=value
					(4) name=value
					    declare -x name
				变量引用：${name}, $name

				注意：bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境
					PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD

				查看环境变量：export, declare -x, printenv, env
				撤销环境变量：unset name  此处非变量引用，所以无需在name前加$

			只读变量：
				(1) declare -r name
				(2) readonly name
                                 举例如下
                                 [root@node1 ~]# readonly name=chenhao 
                                 [root@node1 ~]# echo $name 
                                                 chenhao
                                 [root@node1 ~]# name=nihao
                                 -bash: name: readonly variable
                               只读变量无法重新赋值，并且不支持撤销；存活时间为当前shell进程的生命周期，随shell进程终止而终止；

	bash特性之多命令执行：
		~]# COMMAND1; COMMAND2; COMMAND3; ...

		逻辑运算：
			运算数：真(true, yes, on, 1)
				    假(false, no, off, 0)

			与：
				1 && 1 = 1
				1 && 0 = 0
				0 && 1 = 0
				0 && 0 = 0
			或：
				1 || 1 = 1
				1 || 0 = 1
				0 || 1 = 1
				0 || 0 = 0
			非：
				! 1 = 0
				! 0 = 1

		短路法则：
			~]# COMMAND1 && COMMAND2
				COMMAND1为“假”，则COMMAND2不会再执行；
				否则，COMMAND1为“真”，则COMMAND2必须执行；

			~]# COMMAND1 || COMMAND2
				COMMAND1为“真”，则COMMAND2不会再执行；
				否则，COMMAND1为“假”，则COMMAND2必须执行；

			示例：~]# id $username || useradd $username 

	shell脚本编程：
		编程语言的分类：根据运行方式
			编译运行：源代码 --> 编译器 （编译）--> 程序文件；
			解释运行：源代码 --> 运行时启动解释器，由解释器边解释边运行；
			
		根据其编程过程中功能的实现是调用库还是调用外部的程序文件：
			shell脚本编程：
				利用系统上的命令及编程组件进行编程；
			完整编程：
				利用库或编程组件进行编程；
				
		编程模型：过程式编程语言，面向对象的编程语言
			程序=指令+数据
				过程式：以指令为中心来组织代码，数据是服务于代码；
					顺序执行
					选择执行
					循环执行
					代表：C，bash
				对象式：以数据为中心来组织代码，围绕数据来组织指令；
					类(class)：实例化对象，method；
					代表：Java, C++, Python
					
		shell脚本编程：过程式编程，解释运行，依赖于外部程序文件运行；
			
			如何写shell脚本：
				脚本文件的第一行，顶格：给出shebang，解释器路径，用于指明解释执行当前脚本的解释器程序文件
					常见的解释器：
						#!/bin/bash
						#!/usr/bin/python
						#!/usr/bin/perl
						
			文本编程器：nano
				行编辑器：sed
				全屏幕编程器：nano, vi, vim
				
			shell脚本是什么？
				命令的堆积；
				但很多命令不具有幂等性，需要用程序逻辑来判断运行条件是否满足，以避免其运行中发生错误；
				
			运行脚本：
				(1) 赋予执行权限，并直接运行此程序文件；
					chmod +x /PATH/TO/SCRIPT_FILE
					/PATH/TO/SCRIPT_FILE
				(2) 直接运行解释器，将脚本以命令行参数传递给解释器程序；
					bash /PATH/TO/SCRIPT_FILE
					
			注意：脚本中的空白行会被解释器忽略；
			            脚本中，除了shebang，余下所有以#开头的行，都会被视作注释行而被忽略；此即为注释行；
				    shell脚本的运行是通过运行一个子shell进程实现的；
					
		练习1：写一个脚本，实现如下功能；
			(1) 显示/etc目录下所有以大写p或小写p开头的文件或目录本身；
                             ll /etc|grep -i 'p'     -i表示忽略字母大小写
			(2) 显示/var目录下的所有文件或目录本身，并将显示结果中的小写字母转换为大写后显示；
                             ll /var/|tr '[a-z]' '[A-Z]' 
			(3) 创建临时文件/tmp/myfile.XXXX;
                            mktemp   /tmp/myfile.XXXX;

		bash的配置文件：
			两类：
				profile类：为交互式登录的shell进程提供配置
				bashrc类：为非交互式登录的shell进程提供配置
				
			登录类型：
				交互式登录shell进程：
					直接通过某终端输入账号和密码后登录打开的shell进程；
					使用su命令：su - USERNAME, 或者使用 su -l USERNAME执行的登录切换；
					
				非交互式登录shell进程：
					su USERNAME执行的登录切换；
					图形界面下打开的终端；
					运行脚本
			
			profile类：
				全局：对所有用户都生效；
					/etc/profile 
					/etc/profile.d/*.sh
					
				用户个人：仅对当前用户有效；
					~/.bash_profile
					
				功用：
					1、用于定义环境变量；(重要
					2、运行命令或脚本；(重要
					
			bashrc类：
				全局：
					/etc/bashrc 
				用户个人：
					~/.bashrc
					
				功用：
					1、定义本地变量；（重要）
					2、定义命令别名；(重要
					
			注意：仅管理员可修改全局配置文件；
			
			交互式登录shell进程：
				/etc/profile --> /etc/profile.d/* --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc
				
			非交互式登录shell进程：
				~/.bashrc --> /etc/bashrc --> /etc/profile.d/*
				
			命令行中定义的特性，例如变量和别名作用域为当前shell进程的生命周期；
			配置文件定义的特性，只对随后新启动的shell进程有效；
			
			让通过配置文件定义的特性立即生效：
				(1) 通过命令行重复定义一次；
				(2) 让shell进程重读配置文件；
					~]# source /PATH/FROM/CONF_FILE
					~]# .  /PATH/FROM/CONF_FILE
					
			问题1：定义对所有用户都生效的命令别名，例如 lftps='lftp 172.16.0.1/pub'？修改/etc/bashrc即可
			问题2：让centos用户登录时，提供其已经登录，并显示当前系统时间？
		
回顾：
	bash的特性：hash, 变量
		命令hash：hash命令
		变量：
			环境变量、本地变量、局部变量
			位置参数变量、特殊变量
			
			变量赋值：name=value, export name=value, declare -x name=value
			变量引用：$name, ${name}
			撤销：unset name			
			
	bash脚本编程，运行脚本
		#!/bin/bash
		# 
		
	bash的配置文件
		profile类：登录式shell
		bashrc类：非登录式shell
		
		登录式shell： /etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc

		非登录式shell：~/.bashrc --> /etc/bashrc --> /etc/profile.d/*.sh


		
bash脚本编程之算术运算

	+，-，*，/,  **, %
	
	算术运算格式：
		(1) let  VAR=算术运算表达式
		(2) VAR=$[算术运算表达式]
		(3) VAR=$((算术运算表达式))
		(4) VAR=$(expr $ARG1 $OP $ARG2)
		
		注意：乘法符号在有些场景中需要使用转义符；
	
	练习：写一个脚本，完成如下功能：
		添加三个用户；
		求此三个用户的UID之和；

文件查找
	
	在文件系统上查找符合条件的文件；
		
		实现工具：locate, find
		
	locate：
		依赖于事先构建好的索引库；
			系统自动实现（周期性任务）；
			手动更新数据库（updatedb）；更新数据库需要时间
			
		工作特性：
			查找速度快；
			模糊查找；
			非实时查找；
			
		locate  [OPTION]...  PATTERN...
			-b：只匹配路径中的基名；
			-c：统计出共有多少个符合条件的文件；
			-r：BRE
			
		注意：索引构建过程需要遍历整个根文件系统，极消耗资源；
		
	find：
		实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找；
		工作特性：
			查找速度略慢；
			精确查找；
			实时查找；
			
		用法:
			find [OPTIONS]  [查找起始路径]  [查找条件]  [处理动作]
				查找起始路径：指定具体搜索目标起始路径；默认为当前目录；
				查找条件：指定的查找标准，可以根据文件名、大小、类型、从属关系、权限等等标准进行；默认为找出指定路径下的所有文件；
				处理动作：对符合查找条件的文件做出的操作，例如删除等操作；默认为输出至标准输出；
			查找条件：
				表达式：选项和测试
				测试：结果通常为布尔型（"true", "false"）
					根据文件名查找：
						-name  "pattern"
						-iname "pattern"
							支持glob风格的通配符；
								*, ?, [], [^]
						-regex pattern：基于正则表达式模式查找文件，匹配是整个路径，而非其名；
						
					根据文件从属关系查找：
						-user USERNAME：查找属主指定用户的所有文件；
						-group GRPNAME：查找属组指定组的所有文件；
						
						-uid UID：查找属主指定的UID的所有文件；
						-gid GID：查找属组指定的GID的所有文件；
						
						-nouser：查找没有属主的文件；
						-nogroup：查找没有属组的文件；
						
					根据文件的类型查找：
						-type TYPE：
							f: 普通文件
							d: 目录文件
							l：符号链接文件
							b：块设备 文件
							c：字符设备文件
							p：管道文件
							s：套接字文件
							
					组合测试：
						与：-a, 默认组合逻辑；
						或：-o
						非：-not, !
						
					练习：
						1、找出/tmp目录下属主为非root的所有文件；
                                                  find  /tmp  ! -user root  -f 
						2、找出/tmp目录下文件名中不包含fstab字符串的文件；
                                                  find /tmp !   -name fstab 
						3、找出/tmp目录下属主为非root，而且文件名不包含fstab字符串的文件；
						  find /tmp ! -user root -a  ! -name fstab 

							!A -a !B = !(A -o B)
							!A -o !B = !(A -a B)
							
					根据文件的大小查找：
						-size [+|-]#UNIT
							常用单位：k, M, G
							
							#UNIT：(#-1, #]
							-#UNIT：[0,#-1]
							+#UNIT：(#, oo)
							
					根据时间戳查找：
						以“天”为单位：
							-atime  [+|-]#
								#：[#, #-1)
								-#：(#, 0]
								+#：(oo, #-1]
							-mtime
							-ctime
							
						以“分钟”为单位：
							-amin
							-mmin
							-cmin
							
					根据权限查找：
						-perm  [/|-]mode
							mode：精确权限匹配；
							/mode：任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足；
								9位权限之间存在“或”关系；
							-mode：每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足；
								9位权限之间存在“与”关系；
								
			处理动作：
				-print：输出至标准输出；默认的动作；
				-ls：类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息；
				-delete：删除查找到的文件；
				-fls /PATH/TO/SOMEFILE：把查找到的所有文件的长格式信息保存至指定文件中；
				-ok COMMAND {} \;   ：对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；
				-exec COMMAND {} \;  ：对查找到的每个文件执行由COMMAND表示的命令；
				
				注意：find传递查找到的文件路径至后面的命令时，是先查找出所有符合条件的文件路径，并一次性传递给后面的命令；
				      但是有些命令不能接受过长的参数，此时命令执行会失败；另一种方式可规避此问题：
				      find | xargs COMMAND
						
课外作业：学习xargs命令的用法；
[root@node2 ~]# find /tmp    -name fstab |ls -l    这是因为ls不接受管道命令，所以他把当前目录列了出来
total 8
-rw-------. 1 root root 1629 Jun  8 08:08 anaconda-ks.cfg
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Desktop
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Documents
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Downloads
-rw-------. 1 root root 1677 Jun  7 23:18 initial-setup-ks.cfg
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Music
drwxr-xr-x. 2 root root   39 Jun  8 08:02 openscap_data
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Pictures
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Public
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Templates
drwxr-xr-x. 2 root root    6 Jun  7 23:23 Videos
[root@node2 ~]# find /tmp    -name fstab |xargs ls -l  通过xargs把参数传递给ls，注意在这里不能使用ll
-rw-r--r-- 1 root root 465 Aug  1 22:00 /tmp/fstab
			练习：
				1、查找/var目录下属主为root，且属组为mail的所有文件或目录；
					~]# find /var -user root -a -group mail -ls

				2、查找/usr目录下不属于root, bin或hadoop的所有文件或目录；用两种方法；
					~]# find /usr -not -user root -a -not -user bin -a -not -user hadoop
					~]# find /usr -not \( -user root -o -user bin -o -user hadoop \) -ls
					
				3、查找/etc目录下最近一周内其内容修改过，且属主不是root用户也不是hadoop用户的文件或目录；
					~]# find /etc -mtime -7 -a -not \( -user root -o -user hadoop \) -ls
					~]# find /etc -mtime -7 -a -not -user root -a -not -user hadoop -ls
					
				4、查找当前系统上没有属或属组，且最近一周内曾被访问过的文件或目录；
					~]# find  /  \( -nouser -o -nogroup \)  -atime  -7  -ls
					
				5、查找/etc目录下大于1M且类型为普通文件的所有文件；
					~]# find /etc -size +1M -type f -exec ls -lh {} \;
					
				6、查找/etc目录下所有用户都没有写权限的文件；
					~]# find /etc -not -perm /222 -type f -ls					
					
				7、查找/etc目录至少有一类用户没有执行权限的文件；
					~]# find /etc -not -perm -111 -type f -ls
					
				8、查找/etc/init.d/目录下，所有用户都有执行权限，且其它用户有写权限的所有文件；
					~]# find /etc -perm -113 -type f -ls
					
		博客作业：find详解
		
Linux系统上的特殊权限

	特殊权限：SUID， SGID， STICKY
	
	安全上下文：
		1、进程以某用户的身份运行； 进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；
		2、权限匹配模型：
			(1) 判断进程的属主，是否为被访问的文件属主；如果是，则应用属主的权限；否则进入第2步；
			(2) 判断进程的属主，是否属于被访问的文件属组；如果是，则应用属组的权限；否则进入第3步；
			(3) 应用other的权限；
			
	SUID：
		默认情况下：用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份在运行； 
		SUID的功用：用户运行某程序时，如果此程序拥有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主；
		
		管理文件的SUID权限：
			chmod u+s FILE...
                        chmod u-s FILE...
		展示位置：属主的执行权限位如果属主原本有执行权限，显示为小写s; 否则，显示为大写S；
				
	SGID：
		功用：当目录属组有写权限，且有SGID权限时，那么所有属于此目录的属组，且以属组身份在此目录中新建文件或目录时，新文件的属组不是用户的基本组，
                      而是此目录的属组；
		
		管理文件的SGID权限：
			chmod g+s FILE...
		        chmod g+s FILE...
		展示位置：属组的执行权限位如果属组原本有执行权限，显示为小写s; 否则，显示为大写S；
			
		
	Sticky：
		功用：对于属组或全局可写的目录，组内的所有用户或系统上的所有用户对在此目录中都能创建新文件或删除所有的已有文件；
                      如果为此类目录设置Sticky权限，则每个用户能创建新文件，且只能删除自己的文件；
		
		管理文件的Sticky权限：
			chmod o+t FILE...
                        chmod o-t FILE...
		展示位置：其它用户的执行权限位如果其它用户原本有执行权限，显示为小写t; 否则，显示为大写T；
				
		系统上的/tmp和/var/tmp目录默认均有sticky权限；

举例查看
[root@node2 ~]# ls -ld /tmp;ls -l /usr/bin/passwd  
drwxrwxrwt. 15 root root 4096 Aug  1 22:21 /tmp
-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd
		
	       管理特殊权限的另一方式：
		suid sgid sticy     八进制权限
				0 0 0  	0
				0 0 1  	1
				0 1 0  	2
				0 1 1  	3
				1 0 0  	4
				1 0 1  	5
				1 1 0  	6
				1 1 1  	7
				
		基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字；
				
			例如：chmod 1777 
			
facl：file access control lists

	文件的额外赋权机制：
		在原来的u,g,o之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制；
		
	getfacl命令：
		getfacl FILE...
			user:USERNAME:MODE
			group:GROUPNAME:MODE
			
	setfacl命令：
		赋权给用户：
			setfacl  -m  u:USERNAME:MODE  FILE...
		赋权级组：
			setfacl  -m  g:GROUPNAME:MODE FILE...
			
		撤销赋权：
			setfacl  -x  u:USERNAME  FILE...
			setfacl  -x  g:GROUPNAME  FILE...

举例如下			
[root@node2 ~]# mkdir test 
[root@node2 ~]# getfacl  test/
# file: test/
# owner: root
# group: root
user::rwx
group::r-x
other::r-x
[root@node2 ~]# setfacl  -m u:chenhao:rwx test/
[root@node2 ~]# getfacl test/ 
# file: test/
# owner: root
# group: root
user::rwx
user:chenhao:rwx
group::r-x
mask::rwx
other::r-x
[root@node2 ~]# setfacl  -x u:chenhao  test/
[root@node2 ~]# getfacl test/ 
# file: test/
# owner: root
# group: root
user::rwx
group::r-x
mask::r-x




